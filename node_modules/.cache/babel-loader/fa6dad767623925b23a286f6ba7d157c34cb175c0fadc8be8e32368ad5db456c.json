{"ast":null,"code":"/**\n * Proper Prim's Algorithm for Maze Generation with Animation\n */\n\n// Helper function to add delay for animation\nconst sleep = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n// Get valid neighbors for a cell\nconst getNeighbors = (row, col, gridSize) => {\n  const neighbors = [];\n  const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n  for (const [dr, dc] of directions) {\n    const newRow = row + dr;\n    const newCol = col + dc;\n    if (newRow >= 0 && newRow < gridSize && newCol >= 0 && newCol < gridSize) {\n      neighbors.push([newRow, newCol]);\n    }\n  }\n  return neighbors;\n};\n\n// Get walls between two cells (for proper maze corridors)\nconst getWallBetween = (cell1, cell2) => {\n  const [r1, c1] = cell1;\n  const [r2, c2] = cell2;\n  const wallRow = (r1 + r2) / 2;\n  const wallCol = (c1 + c2) / 2;\n  return [wallRow, wallCol];\n};\n\n/**\n * Generates a maze using Prim's algorithm with step-by-step animation\n * @param {number} gridSize - The size of the grid\n * @param {Function} updateWalls - Callback to update UI with current walls\n * @param {Function} updateMazeGeneration - Callback to update UI with maze generation cells\n * @param {number} animationSpeed - Speed of animation in milliseconds\n * @returns {Object} - Results including final walls set and generation stats\n */\nexport const generateMazeWithPrims = async (gridSize, updateWalls, updateMazeGeneration, animationSpeed = 150) => {\n  // Initialize: Start with all cells as walls\n  const walls = new Set();\n  const passages = new Set();\n  const visited = new Set();\n  const frontierWalls = [];\n  const mazeGenerationCells = new Set();\n\n  // Step 1: Fill entire grid with walls\n  for (let row = 0; row < gridSize; row++) {\n    for (let col = 0; col < gridSize; col++) {\n      walls.add(`${row}-${col}`);\n    }\n  }\n\n  // Step 2: Pick a random starting cell in the interior (ensure odd coordinates for proper maze)\n  const startRow = 1 + Math.floor(Math.random() * Math.floor((gridSize - 2) / 2)) * 2;\n  const startCol = 1 + Math.floor(Math.random() * Math.floor((gridSize - 2) / 2)) * 2;\n  const startCell = `${startRow}-${startCol}`;\n\n  // Step 3: Carve the starting cell (make it a passage)\n  walls.delete(startCell);\n  passages.add(startCell);\n  visited.add(startCell);\n\n  // Step 4: Add walls adjacent to the starting cell to frontier\n  const addAdjacentWallsToFrontier = (row, col) => {\n    const directions = [[-2, 0], [2, 0], [0, -2], [0, 2]];\n    for (const [dr, dc] of directions) {\n      const newRow = row + dr;\n      const newCol = col + dc;\n      if (newRow > 0 && newRow < gridSize - 1 && newCol > 0 && newCol < gridSize - 1) {\n        if (!visited.has(`${newRow}-${newCol}`)) {\n          frontierWalls.push([newRow, newCol]);\n        }\n      }\n    }\n  };\n  addAdjacentWallsToFrontier(startRow, startCol);\n  let generationSteps = 0;\n\n  // Update initial state\n  updateWalls(new Set(walls));\n  updateMazeGeneration(new Set([startCell]));\n  await sleep(animationSpeed);\n\n  // Main Prim's algorithm loop\n  while (frontierWalls.length > 0) {\n    // Pick a random frontier wall\n    const randomIndex = Math.floor(Math.random() * frontierWalls.length);\n    const [wallRow, wallCol] = frontierWalls.splice(randomIndex, 1)[0];\n    const wallCell = `${wallRow}-${wallCol}`;\n\n    // Get adjacent cells that are already passages\n    const adjacentPassages = [];\n    const directions = [[-2, 0], [2, 0], [0, -2], [0, 2]];\n    for (const [dr, dc] of directions) {\n      const adjRow = wallRow + dr;\n      const adjCol = wallCol + dc;\n      if (adjRow >= 0 && adjRow < gridSize && adjCol >= 0 && adjCol < gridSize) {\n        if (passages.has(`${adjRow}-${adjCol}`)) {\n          adjacentPassages.push([adjRow, adjCol]);\n        }\n      }\n    }\n\n    // If this wall has exactly one adjacent passage, carve it\n    if (adjacentPassages.length === 1) {\n      // Carve this wall (make it a passage)\n      walls.delete(wallCell);\n      passages.add(wallCell);\n      visited.add(wallCell);\n      mazeGenerationCells.add(wallCell);\n\n      // Also carve the wall between the frontier cell and the adjacent passage\n      const [adjRow, adjCol] = adjacentPassages[0];\n      const betweenRow = (wallRow + adjRow) / 2;\n      const betweenCol = (wallCol + adjCol) / 2;\n      const betweenCell = `${betweenRow}-${betweenCol}`;\n      walls.delete(betweenCell);\n      passages.add(betweenCell);\n      mazeGenerationCells.add(betweenCell);\n\n      // Add new frontier walls\n      addAdjacentWallsToFrontier(wallRow, wallCol);\n      generationSteps++;\n\n      // Update UI with animation\n      updateWalls(new Set(walls));\n      updateMazeGeneration(new Set(mazeGenerationCells));\n      await sleep(animationSpeed);\n    }\n  }\n\n  // Clear maze generation cells after a delay\n  setTimeout(() => {\n    updateMazeGeneration(new Set());\n  }, 1500);\n  return {\n    walls: new Set(walls),\n    passages: new Set(passages),\n    generationSteps,\n    visitedCells: passages.size\n  };\n};\nexport default generateMazeWithPrims;","map":{"version":3,"names":["sleep","ms","Promise","resolve","setTimeout","getNeighbors","row","col","gridSize","neighbors","directions","dr","dc","newRow","newCol","push","getWallBetween","cell1","cell2","r1","c1","r2","c2","wallRow","wallCol","generateMazeWithPrims","updateWalls","updateMazeGeneration","animationSpeed","walls","Set","passages","visited","frontierWalls","mazeGenerationCells","add","startRow","Math","floor","random","startCol","startCell","delete","addAdjacentWallsToFrontier","has","generationSteps","length","randomIndex","splice","wallCell","adjacentPassages","adjRow","adjCol","betweenRow","betweenCol","betweenCell","visitedCells","size"],"sources":["E:/maze_analyser/src/algorithms/primsAlgorithm.js"],"sourcesContent":["/**\n * Proper Prim's Algorithm for Maze Generation with Animation\n */\n\n// Helper function to add delay for animation\nconst sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));\n\n// Get valid neighbors for a cell\nconst getNeighbors = (row, col, gridSize) => {\n  const neighbors = [];\n  const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n  \n  for (const [dr, dc] of directions) {\n    const newRow = row + dr;\n    const newCol = col + dc;\n    if (newRow >= 0 && newRow < gridSize && newCol >= 0 && newCol < gridSize) {\n      neighbors.push([newRow, newCol]);\n    }\n  }\n  return neighbors;\n};\n\n// Get walls between two cells (for proper maze corridors)\nconst getWallBetween = (cell1, cell2) => {\n  const [r1, c1] = cell1;\n  const [r2, c2] = cell2;\n  const wallRow = (r1 + r2) / 2;\n  const wallCol = (c1 + c2) / 2;\n  return [wallRow, wallCol];\n};\n\n/**\n * Generates a maze using Prim's algorithm with step-by-step animation\n * @param {number} gridSize - The size of the grid\n * @param {Function} updateWalls - Callback to update UI with current walls\n * @param {Function} updateMazeGeneration - Callback to update UI with maze generation cells\n * @param {number} animationSpeed - Speed of animation in milliseconds\n * @returns {Object} - Results including final walls set and generation stats\n */\nexport const generateMazeWithPrims = async (\n  gridSize,\n  updateWalls,\n  updateMazeGeneration,\n  animationSpeed = 150\n) => {\n  // Initialize: Start with all cells as walls\n  const walls = new Set();\n  const passages = new Set();\n  const visited = new Set();\n  const frontierWalls = [];\n  const mazeGenerationCells = new Set();\n  \n  // Step 1: Fill entire grid with walls\n  for (let row = 0; row < gridSize; row++) {\n    for (let col = 0; col < gridSize; col++) {\n      walls.add(`${row}-${col}`);\n    }\n  }\n  \n  // Step 2: Pick a random starting cell in the interior (ensure odd coordinates for proper maze)\n  const startRow = 1 + Math.floor(Math.random() * Math.floor((gridSize - 2) / 2)) * 2;\n  const startCol = 1 + Math.floor(Math.random() * Math.floor((gridSize - 2) / 2)) * 2;\n  const startCell = `${startRow}-${startCol}`;\n  \n  // Step 3: Carve the starting cell (make it a passage)\n  walls.delete(startCell);\n  passages.add(startCell);\n  visited.add(startCell);\n  \n  // Step 4: Add walls adjacent to the starting cell to frontier\n  const addAdjacentWallsToFrontier = (row, col) => {\n    const directions = [[-2, 0], [2, 0], [0, -2], [0, 2]];\n    for (const [dr, dc] of directions) {\n      const newRow = row + dr;\n      const newCol = col + dc;\n      if (newRow > 0 && newRow < gridSize - 1 && newCol > 0 && newCol < gridSize - 1) {\n        if (!visited.has(`${newRow}-${newCol}`)) {\n          frontierWalls.push([newRow, newCol]);\n        }\n      }\n    }\n  };\n  \n  addAdjacentWallsToFrontier(startRow, startCol);\n  \n  let generationSteps = 0;\n  \n  // Update initial state\n  updateWalls(new Set(walls));\n  updateMazeGeneration(new Set([startCell]));\n  await sleep(animationSpeed);\n\n  // Main Prim's algorithm loop\n  while (frontierWalls.length > 0) {\n    // Pick a random frontier wall\n    const randomIndex = Math.floor(Math.random() * frontierWalls.length);\n    const [wallRow, wallCol] = frontierWalls.splice(randomIndex, 1)[0];\n    const wallCell = `${wallRow}-${wallCol}`;\n    \n    // Get adjacent cells that are already passages\n    const adjacentPassages = [];\n    const directions = [[-2, 0], [2, 0], [0, -2], [0, 2]];\n    for (const [dr, dc] of directions) {\n      const adjRow = wallRow + dr;\n      const adjCol = wallCol + dc;\n      if (adjRow >= 0 && adjRow < gridSize && adjCol >= 0 && adjCol < gridSize) {\n        if (passages.has(`${adjRow}-${adjCol}`)) {\n          adjacentPassages.push([adjRow, adjCol]);\n        }\n      }\n    }\n    \n    // If this wall has exactly one adjacent passage, carve it\n    if (adjacentPassages.length === 1) {\n      // Carve this wall (make it a passage)\n      walls.delete(wallCell);\n      passages.add(wallCell);\n      visited.add(wallCell);\n      mazeGenerationCells.add(wallCell);\n      \n      // Also carve the wall between the frontier cell and the adjacent passage\n      const [adjRow, adjCol] = adjacentPassages[0];\n      const betweenRow = (wallRow + adjRow) / 2;\n      const betweenCol = (wallCol + adjCol) / 2;\n      const betweenCell = `${betweenRow}-${betweenCol}`;\n      walls.delete(betweenCell);\n      passages.add(betweenCell);\n      mazeGenerationCells.add(betweenCell);\n      \n      // Add new frontier walls\n      addAdjacentWallsToFrontier(wallRow, wallCol);\n      \n      generationSteps++;\n      \n      // Update UI with animation\n      updateWalls(new Set(walls));\n      updateMazeGeneration(new Set(mazeGenerationCells));\n      await sleep(animationSpeed);\n    }\n  }\n\n  // Clear maze generation cells after a delay\n  setTimeout(() => {\n    updateMazeGeneration(new Set());\n  }, 1500);\n  \n  return {\n    walls: new Set(walls),\n    passages: new Set(passages),\n    generationSteps,\n    visitedCells: passages.size\n  };\n};\n\nexport default generateMazeWithPrims;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}