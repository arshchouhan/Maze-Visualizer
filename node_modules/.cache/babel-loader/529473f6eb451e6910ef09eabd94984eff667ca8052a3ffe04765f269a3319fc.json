{"ast":null,"code":"/**\n * Depth-First Search (DFS) Algorithm Implementation\n * \n * This algorithm explores the grid by going as far as possible along each branch before backtracking.\n * It uses a stack (LIFO) for exploration, which can be implemented using recursion or an explicit stack.\n * \n * DFS doesn't guarantee the shortest path but can be more memory efficient than BFS.\n */\n\n/**\n * Implements the Depth-First Search algorithm to find a path\n * @param {number} gridSize - The size of the grid (gridSize x gridSize)\n * @param {Object} startPos - The starting position {row, col}\n * @param {Object} targetPos - The target position {row, col}\n * @param {Set} walls - Set of wall positions in \"row-col\" format\n * @param {Function} updateVisited - Callback to update UI with visited cells\n * @param {Function} updatePath - Callback to update UI with final path\n * @returns {Object} - Results including whether path was found, path, visited nodes count\n */\nexport const depthFirstSearch = async (gridSize, startPos, targetPos, walls, updateVisited, updatePath) => {\n  // Data structures needed for DFS\n  const stack = []; // Stack for DFS traversal (using array with push/pop for LIFO)\n  const visited = new Set(); // Track visited cells\n  const parent = new Map(); // Track the path to reconstruct later\n  let pathFound = false;\n  let visitedCount = 0;\n\n  // Convert positions to string format for easy comparison\n  const startPosStr = `${startPos.row}-${startPos.col}`;\n  const targetPosStr = `${targetPos.row}-${targetPos.col}`;\n\n  // Initialize DFS with the start position\n  stack.push(startPosStr);\n\n  // Define the four possible directions: up, right, down, left\n  const directions = [[-1, 0],\n  // up\n  [0, 1],\n  // right\n  [1, 0],\n  // down\n  [0, -1] // left\n  ];\n\n  // Simulate async delay for visualization\n  const delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n  // DFS main loop using explicit stack\n  while (stack.length > 0) {\n    const current = stack[stack.length - 1]; // Peek at the top of the stack\n\n    // If we've already visited this node, pop it from the stack\n    if (visited.has(current)) {\n      stack.pop();\n      continue;\n    }\n    const [currentRow, currentCol] = current.split('-').map(Number);\n\n    // Mark as visited when we're about to process it\n    visited.add(current);\n    visitedCount++;\n\n    // Check if we've reached the target\n    if (current === targetPosStr) {\n      pathFound = true;\n      break;\n    }\n\n    // Update UI to show the current cell as visited\n    if (updateVisited && current !== startPosStr) {\n      updateVisited(currentRow, currentCol);\n      await delay(20); // Small delay for visualization\n    }\n\n    // Find all valid, unvisited neighbors\n    const unvisitedNeighbors = [];\n    for (const [dx, dy] of directions) {\n      const newRow = currentRow + dx;\n      const newCol = currentCol + dy;\n      const newPos = `${newRow}-${newCol}`;\n      if (newRow >= 0 && newRow < gridSize && newCol >= 0 && newCol < gridSize && !walls.has(newPos) && !visited.has(newPos)) {\n        unvisitedNeighbors.push(newPos);\n      }\n    }\n\n    // If no unvisited neighbors, backtrack\n    if (unvisitedNeighbors.length === 0) {\n      stack.pop();\n    } else {\n      // Push all unvisited neighbors to the stack in reverse order\n      // so they're processed in the original direction order\n      for (let i = unvisitedNeighbors.length - 1; i >= 0; i--) {\n        const neighbor = unvisitedNeighbors[i];\n        if (!parent.has(neighbor)) {\n          parent.set(neighbor, current);\n        }\n        stack.push(neighbor);\n      }\n    }\n  }\n\n  // Reconstruct the path if target was found\n  const path = [];\n  if (pathFound) {\n    let current = targetPosStr;\n\n    // Work backward from target to start\n    while (current !== startPosStr) {\n      const [row, col] = current.split('-').map(Number);\n      path.unshift({\n        row,\n        col\n      }); // Add to the beginning of the path array\n      current = parent.get(current);\n    }\n\n    // Update UI with the final path\n    if (updatePath) {\n      for (const {\n        row,\n        col\n      } of path) {\n        updatePath(row, col);\n        await delay(50); // Slightly longer delay for path visualization\n      }\n    }\n  }\n\n  // Return the results\n  return {\n    pathFound,\n    path,\n    visitedCount,\n    pathLength: path.length\n  };\n};\n\n/**\n * Helper function to visualize DFS step by step\n * This is a simpler version that returns all the steps for visualization\n */\nexport const getDFSSteps = (gridSize, startPos, targetPos, walls) => {\n  const steps = [];\n  const stack = [];\n  const visited = new Set();\n  const parent = new Map();\n  const startPosStr = `${startPos.row}-${startPos.col}`;\n  const targetPosStr = `${targetPos.row}-${targetPos.col}`;\n  stack.push(startPosStr);\n  const directions = [[-1, 0], [0, 1], [1, 0], [0, -1]];\n  let pathFound = false;\n  while (stack.length > 0) {\n    const current = stack[stack.length - 1]; // Peek at the top of the stack\n\n    // If we've already visited this node, pop it from the stack\n    if (visited.has(current)) {\n      stack.pop();\n      continue;\n    }\n    const [currentRow, currentCol] = current.split('-').map(Number);\n    visited.add(current);\n    steps.push({\n      type: 'visit',\n      position: current\n    });\n\n    // Check if we've reached the target\n    if (current === targetPosStr) {\n      pathFound = true;\n      break;\n    }\n\n    // Find all valid, unvisited neighbors\n    const unvisitedNeighbors = [];\n    for (const [dx, dy] of directions) {\n      const newRow = currentRow + dx;\n      const newCol = currentCol + dy;\n      const newPos = `${newRow}-${newCol}`;\n      if (newRow >= 0 && newRow < gridSize && newCol >= 0 && newCol < gridSize && !walls.has(newPos) && !visited.has(newPos)) {\n        unvisitedNeighbors.push(newPos);\n      }\n    }\n\n    // If no unvisited neighbors, backtrack\n    if (unvisitedNeighbors.length === 0) {\n      stack.pop();\n    } else {\n      // Push all unvisited neighbors to the stack in reverse order\n      // so they're processed in the original direction order\n      for (let i = unvisitedNeighbors.length - 1; i >= 0; i--) {\n        const neighbor = unvisitedNeighbors[i];\n        if (!parent.has(neighbor)) {\n          parent.set(neighbor, current);\n        }\n        stack.push(neighbor);\n      }\n    }\n  }\n\n  // Reconstruct path if found\n  if (pathFound) {\n    const path = [];\n    let current = targetPosStr;\n    while (current !== startPosStr) {\n      path.unshift(current);\n      steps.push({\n        type: 'path',\n        position: current\n      });\n      current = parent.get(current);\n    }\n  }\n  return {\n    steps,\n    pathFound,\n    visitedCount: visited.size - 1 // Don't count start node\n  };\n};\nexport default depthFirstSearch;","map":{"version":3,"names":["depthFirstSearch","gridSize","startPos","targetPos","walls","updateVisited","updatePath","stack","visited","Set","parent","Map","pathFound","visitedCount","startPosStr","row","col","targetPosStr","push","directions","delay","ms","Promise","resolve","setTimeout","length","current","has","pop","currentRow","currentCol","split","map","Number","add","unvisitedNeighbors","dx","dy","newRow","newCol","newPos","i","neighbor","set","path","unshift","get","pathLength","getDFSSteps","steps","type","position","size"],"sources":["E:/maze_analyser/src/algorithms/depthFirstSearch.js"],"sourcesContent":["/**\n * Depth-First Search (DFS) Algorithm Implementation\n * \n * This algorithm explores the grid by going as far as possible along each branch before backtracking.\n * It uses a stack (LIFO) for exploration, which can be implemented using recursion or an explicit stack.\n * \n * DFS doesn't guarantee the shortest path but can be more memory efficient than BFS.\n */\n\n/**\n * Implements the Depth-First Search algorithm to find a path\n * @param {number} gridSize - The size of the grid (gridSize x gridSize)\n * @param {Object} startPos - The starting position {row, col}\n * @param {Object} targetPos - The target position {row, col}\n * @param {Set} walls - Set of wall positions in \"row-col\" format\n * @param {Function} updateVisited - Callback to update UI with visited cells\n * @param {Function} updatePath - Callback to update UI with final path\n * @returns {Object} - Results including whether path was found, path, visited nodes count\n */\nexport const depthFirstSearch = async (\n  gridSize,\n  startPos,\n  targetPos,\n  walls,\n  updateVisited,\n  updatePath\n) => {\n  // Data structures needed for DFS\n  const stack = []; // Stack for DFS traversal (using array with push/pop for LIFO)\n  const visited = new Set(); // Track visited cells\n  const parent = new Map(); // Track the path to reconstruct later\n  let pathFound = false;\n  let visitedCount = 0;\n  \n  // Convert positions to string format for easy comparison\n  const startPosStr = `${startPos.row}-${startPos.col}`;\n  const targetPosStr = `${targetPos.row}-${targetPos.col}`;\n  \n  // Initialize DFS with the start position\n  stack.push(startPosStr);\n  \n  // Define the four possible directions: up, right, down, left\n  const directions = [\n    [-1, 0],  // up\n    [0, 1],   // right\n    [1, 0],   // down\n    [0, -1]   // left\n  ];\n  \n  // Simulate async delay for visualization\n  const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));\n  \n  // DFS main loop using explicit stack\n  while (stack.length > 0) {\n    const current = stack[stack.length - 1]; // Peek at the top of the stack\n    \n    // If we've already visited this node, pop it from the stack\n    if (visited.has(current)) {\n      stack.pop();\n      continue;\n    }\n    \n    const [currentRow, currentCol] = current.split('-').map(Number);\n    \n    // Mark as visited when we're about to process it\n    visited.add(current);\n    visitedCount++;\n    \n    // Check if we've reached the target\n    if (current === targetPosStr) {\n      pathFound = true;\n      break;\n    }\n    \n    // Update UI to show the current cell as visited\n    if (updateVisited && current !== startPosStr) {\n      updateVisited(currentRow, currentCol);\n      await delay(20); // Small delay for visualization\n    }\n    \n    // Find all valid, unvisited neighbors\n    const unvisitedNeighbors = [];\n    for (const [dx, dy] of directions) {\n      const newRow = currentRow + dx;\n      const newCol = currentCol + dy;\n      const newPos = `${newRow}-${newCol}`;\n      \n      if (newRow >= 0 && newRow < gridSize && \n          newCol >= 0 && newCol < gridSize &&\n          !walls.has(newPos) && !visited.has(newPos)) {\n        unvisitedNeighbors.push(newPos);\n      }\n    }\n    \n    // If no unvisited neighbors, backtrack\n    if (unvisitedNeighbors.length === 0) {\n      stack.pop();\n    } else {\n      // Push all unvisited neighbors to the stack in reverse order\n      // so they're processed in the original direction order\n      for (let i = unvisitedNeighbors.length - 1; i >= 0; i--) {\n        const neighbor = unvisitedNeighbors[i];\n        if (!parent.has(neighbor)) {\n          parent.set(neighbor, current);\n        }\n        stack.push(neighbor);\n      }\n    }\n  }\n  \n  // Reconstruct the path if target was found\n  const path = [];\n  if (pathFound) {\n    let current = targetPosStr;\n    \n    // Work backward from target to start\n    while (current !== startPosStr) {\n      const [row, col] = current.split('-').map(Number);\n      path.unshift({ row, col }); // Add to the beginning of the path array\n      current = parent.get(current);\n    }\n    \n    // Update UI with the final path\n    if (updatePath) {\n      for (const { row, col } of path) {\n        updatePath(row, col);\n        await delay(50); // Slightly longer delay for path visualization\n      }\n    }\n  }\n  \n  // Return the results\n  return {\n    pathFound,\n    path,\n    visitedCount,\n    pathLength: path.length\n  };\n};\n\n/**\n * Helper function to visualize DFS step by step\n * This is a simpler version that returns all the steps for visualization\n */\nexport const getDFSSteps = (gridSize, startPos, targetPos, walls) => {\n  const steps = [];\n  const stack = [];\n  const visited = new Set();\n  const parent = new Map();\n  \n  const startPosStr = `${startPos.row}-${startPos.col}`;\n  const targetPosStr = `${targetPos.row}-${targetPos.col}`;\n  \n  stack.push(startPosStr);\n  \n  const directions = [[-1, 0], [0, 1], [1, 0], [0, -1]];\n  let pathFound = false;\n  \n  while (stack.length > 0) {\n    const current = stack[stack.length - 1]; // Peek at the top of the stack\n    \n    // If we've already visited this node, pop it from the stack\n    if (visited.has(current)) {\n      stack.pop();\n      continue;\n    }\n    \n    const [currentRow, currentCol] = current.split('-').map(Number);\n    visited.add(current);\n    steps.push({ type: 'visit', position: current });\n    \n    // Check if we've reached the target\n    if (current === targetPosStr) {\n      pathFound = true;\n      break;\n    }\n    \n    // Find all valid, unvisited neighbors\n    const unvisitedNeighbors = [];\n    for (const [dx, dy] of directions) {\n      const newRow = currentRow + dx;\n      const newCol = currentCol + dy;\n      const newPos = `${newRow}-${newCol}`;\n      \n      if (newRow >= 0 && newRow < gridSize && \n          newCol >= 0 && newCol < gridSize &&\n          !walls.has(newPos) && !visited.has(newPos)) {\n        unvisitedNeighbors.push(newPos);\n      }\n    }\n    \n    // If no unvisited neighbors, backtrack\n    if (unvisitedNeighbors.length === 0) {\n      stack.pop();\n    } else {\n      // Push all unvisited neighbors to the stack in reverse order\n      // so they're processed in the original direction order\n      for (let i = unvisitedNeighbors.length - 1; i >= 0; i--) {\n        const neighbor = unvisitedNeighbors[i];\n        if (!parent.has(neighbor)) {\n          parent.set(neighbor, current);\n        }\n        stack.push(neighbor);\n      }\n    }\n  \n  }\n  \n  // Reconstruct path if found\n  if (pathFound) {\n    const path = [];\n    let current = targetPosStr;\n    \n    while (current !== startPosStr) {\n      path.unshift(current);\n      steps.push({ type: 'path', position: current });\n      current = parent.get(current);\n    }\n  }\n  \n  return {\n    steps,\n    pathFound,\n    visitedCount: visited.size - 1 // Don't count start node\n  };\n};\n\nexport default depthFirstSearch;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}