{"ast":null,"code":"/**\n * Recursive Division Algorithm for Maze Generation\n * \n * This algorithm generates a maze by starting with an empty space and \n * recursively dividing it with walls, leaving passages through each wall.\n * \n * Data Structures Used:\n * - Set: For tracking walls and division cells\n * - Array: For managing division operations and animation steps\n * - Recursive function calls: For the division process\n */\n\n/**\n * Generates a maze using Recursive Division algorithm with systematic grid-like animation\n * @param {number} gridSize - The size of the grid (gridSize x gridSize)\n * @param {Function} updateWalls - Callback to update UI with current walls\n * @param {Function} updateMazeGeneration - Callback to update UI with maze generation cells\n * @param {number} animationSpeed - Speed of animation in milliseconds\n * @returns {Object} - Results including final walls set and generation stats\n */\nexport const generateMazeWithRecursiveDivision = async (gridSize, updateWalls, updateMazeGeneration, animationSpeed = 150) => {\n  const walls = new Set();\n  const mazeGenerationCells = new Set();\n  let generationSteps = 0;\n\n  // Initialize: Start with border walls only\n  for (let row = 0; row < gridSize; row++) {\n    for (let col = 0; col < gridSize; col++) {\n      // Only create border walls initially\n      if (row === 0 || row === gridSize - 1 || col === 0 || col === gridSize - 1) {\n        walls.add(`${row}-${col}`);\n      }\n    }\n  }\n\n  // Update initial state (empty interior with border walls)\n  updateWalls(new Set(walls));\n  updateMazeGeneration(new Set());\n  await sleep(animationSpeed);\n\n  // Create systematic grid-like divisions\n  await createSystematicDivisions(gridSize, walls, mazeGenerationCells, updateWalls, updateMazeGeneration, animationSpeed, () => {\n    generationSteps++;\n  });\n\n  // Clear maze generation cells after completion\n  setTimeout(() => {\n    updateMazeGeneration(new Set());\n  }, 1500);\n  return {\n    walls: new Set(walls),\n    generationSteps,\n    visitedCells: gridSize * gridSize - walls.size\n  };\n};\n\n/**\n * Create systematic grid-like divisions\n * First creates vertical lines, then fills in horizontal divisions within each section\n * @param {number} gridSize - Size of the grid\n * @param {Set} walls - Current walls set\n * @param {Set} mazeGenerationCells - Cells being processed\n * @param {Function} updateWalls - Callback to update walls\n * @param {Function} updateMazeGeneration - Callback to update generation cells\n * @param {number} animationSpeed - Animation delay\n * @param {Function} incrementSteps - Callback to increment step counter\n */\nasync function createSystematicDivisions(gridSize, walls, mazeGenerationCells, updateWalls, updateMazeGeneration, animationSpeed, incrementSteps) {\n  const sections = [];\n\n  // Step 1: Create vertical divisions first (top-to-bottom lines)\n  const numVerticalDivisions = Math.floor((gridSize - 2) / 4); // Create divisions every 4 cells\n\n  for (let i = 1; i <= numVerticalDivisions; i++) {\n    const wallCol = 1 + i * Math.floor((gridSize - 2) / (numVerticalDivisions + 1));\n\n    // Create full vertical line from top to bottom\n    await createVerticalWall(wallCol, 1, gridSize - 2, walls, mazeGenerationCells, updateWalls, updateMazeGeneration, animationSpeed, incrementSteps);\n  }\n\n  // Step 2: Define sections created by vertical walls\n  let sectionStart = 1;\n  for (let i = 0; i <= numVerticalDivisions; i++) {\n    let sectionEnd;\n    if (i === numVerticalDivisions) {\n      sectionEnd = gridSize - 1;\n    } else {\n      sectionEnd = 1 + (i + 1) * Math.floor((gridSize - 2) / (numVerticalDivisions + 1));\n    }\n    sections.push({\n      startCol: sectionStart,\n      endCol: sectionEnd - 1,\n      startRow: 1,\n      endRow: gridSize - 1\n    });\n    sectionStart = sectionEnd + 1;\n  }\n\n  // Step 3: Fill each section with horizontal divisions\n  for (const section of sections) {\n    await fillSectionWithHorizontalDivisions(section, walls, mazeGenerationCells, updateWalls, updateMazeGeneration, animationSpeed, incrementSteps);\n  }\n}\n\n/**\n * Create a vertical wall from top to bottom with a random passage\n */\nasync function createVerticalWall(wallCol, startRow, height, walls, mazeGenerationCells, updateWalls, updateMazeGeneration, animationSpeed, incrementSteps) {\n  // Choose a random position for the passage\n  const passageRow = startRow + Math.floor(Math.random() * height);\n\n  // Add vertical wall with passage\n  const newWallCells = [];\n  for (let row = startRow; row < startRow + height; row++) {\n    if (row !== passageRow) {\n      const cellKey = `${row}-${wallCol}`;\n      walls.add(cellKey);\n      mazeGenerationCells.add(cellKey);\n      newWallCells.push(cellKey);\n    }\n  }\n\n  // Animate the wall creation\n  incrementSteps();\n  updateWalls(new Set(walls));\n  updateMazeGeneration(new Set(mazeGenerationCells));\n  await sleep(animationSpeed);\n\n  // Remove the wall cells from generation display after a short delay\n  setTimeout(() => {\n    newWallCells.forEach(cell => mazeGenerationCells.delete(cell));\n    updateMazeGeneration(new Set(mazeGenerationCells));\n  }, animationSpeed * 1.5);\n}\n\n/**\n * Fill a section with horizontal divisions\n */\nasync function fillSectionWithHorizontalDivisions(section, walls, mazeGenerationCells, updateWalls, updateMazeGeneration, animationSpeed, incrementSteps) {\n  const sectionWidth = section.endCol - section.startCol + 1;\n  const sectionHeight = section.endRow - section.startRow + 1;\n\n  // Only add horizontal divisions if section is large enough\n  if (sectionHeight < 4 || sectionWidth < 2) {\n    return;\n  }\n\n  // Create 1-2 horizontal divisions in this section\n  const numHorizontalDivisions = Math.floor(sectionHeight / 6) || 1;\n  for (let i = 1; i <= numHorizontalDivisions; i++) {\n    const wallRow = section.startRow + i * Math.floor(sectionHeight / (numHorizontalDivisions + 1));\n\n    // Skip if wall would be too close to boundaries\n    if (wallRow <= section.startRow + 1 || wallRow >= section.endRow - 1) {\n      continue;\n    }\n\n    // Choose a random position for the passage\n    const passageCol = section.startCol + Math.floor(Math.random() * sectionWidth);\n\n    // Add horizontal wall with passage\n    const newWallCells = [];\n    for (let col = section.startCol; col <= section.endCol; col++) {\n      if (col !== passageCol) {\n        const cellKey = `${wallRow}-${col}`;\n        walls.add(cellKey);\n        mazeGenerationCells.add(cellKey);\n        newWallCells.push(cellKey);\n      }\n    }\n\n    // Animate the wall creation\n    incrementSteps();\n    updateWalls(new Set(walls));\n    updateMazeGeneration(new Set(mazeGenerationCells));\n    await sleep(animationSpeed);\n\n    // Remove the wall cells from generation display after a short delay\n    setTimeout(() => {\n      newWallCells.forEach(cell => mazeGenerationCells.delete(cell));\n      updateMazeGeneration(new Set(mazeGenerationCells));\n    }, animationSpeed * 1.5);\n  }\n}\n\n/**\n * Sleep function for animation delays\n */\nfunction sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n/**\n * Generate maze steps for step-by-step visualization (simplified version)\n */\nexport const getRecursiveDivisionSteps = gridSize => {\n  const steps = [];\n  const walls = new Set();\n\n  // Initialize with border walls\n  for (let row = 0; row < gridSize; row++) {\n    for (let col = 0; col < gridSize; col++) {\n      if (row === 0 || row === gridSize - 1 || col === 0 || col === gridSize - 1) {\n        walls.add(`${row}-${col}`);\n      }\n    }\n  }\n  steps.push({\n    walls: new Set(walls),\n    action: 'start',\n    description: 'Starting with border walls only'\n  });\n\n  // This would contain the recursive division steps\n  // For now, return the initial step\n  return steps;\n};\nexport default generateMazeWithRecursiveDivision;","map":{"version":3,"names":["generateMazeWithRecursiveDivision","gridSize","updateWalls","updateMazeGeneration","animationSpeed","walls","Set","mazeGenerationCells","generationSteps","row","col","add","sleep","createSystematicDivisions","setTimeout","visitedCells","size","incrementSteps","sections","numVerticalDivisions","Math","floor","i","wallCol","createVerticalWall","sectionStart","sectionEnd","push","startCol","endCol","startRow","endRow","section","fillSectionWithHorizontalDivisions","height","passageRow","random","newWallCells","cellKey","forEach","cell","delete","sectionWidth","sectionHeight","numHorizontalDivisions","wallRow","passageCol","ms","Promise","resolve","getRecursiveDivisionSteps","steps","action","description"],"sources":["E:/maze_analyser/src/algorithms/recursiveDivision.js"],"sourcesContent":["/**\n * Recursive Division Algorithm for Maze Generation\n * \n * This algorithm generates a maze by starting with an empty space and \n * recursively dividing it with walls, leaving passages through each wall.\n * \n * Data Structures Used:\n * - Set: For tracking walls and division cells\n * - Array: For managing division operations and animation steps\n * - Recursive function calls: For the division process\n */\n\n/**\n * Generates a maze using Recursive Division algorithm with systematic grid-like animation\n * @param {number} gridSize - The size of the grid (gridSize x gridSize)\n * @param {Function} updateWalls - Callback to update UI with current walls\n * @param {Function} updateMazeGeneration - Callback to update UI with maze generation cells\n * @param {number} animationSpeed - Speed of animation in milliseconds\n * @returns {Object} - Results including final walls set and generation stats\n */\nexport const generateMazeWithRecursiveDivision = async (\n  gridSize,\n  updateWalls,\n  updateMazeGeneration,\n  animationSpeed = 150\n) => {\n  const walls = new Set();\n  const mazeGenerationCells = new Set();\n  let generationSteps = 0;\n  \n  // Initialize: Start with border walls only\n  for (let row = 0; row < gridSize; row++) {\n    for (let col = 0; col < gridSize; col++) {\n      // Only create border walls initially\n      if (row === 0 || row === gridSize - 1 || col === 0 || col === gridSize - 1) {\n        walls.add(`${row}-${col}`);\n      }\n    }\n  }\n  \n  // Update initial state (empty interior with border walls)\n  updateWalls(new Set(walls));\n  updateMazeGeneration(new Set());\n  await sleep(animationSpeed);\n  \n  // Create systematic grid-like divisions\n  await createSystematicDivisions(\n    gridSize,\n    walls,\n    mazeGenerationCells,\n    updateWalls,\n    updateMazeGeneration,\n    animationSpeed,\n    () => { generationSteps++; }\n  );\n  \n  // Clear maze generation cells after completion\n  setTimeout(() => {\n    updateMazeGeneration(new Set());\n  }, 1500);\n  \n  return {\n    walls: new Set(walls),\n    generationSteps,\n    visitedCells: gridSize * gridSize - walls.size\n  };\n};\n\n/**\n * Create systematic grid-like divisions\n * First creates vertical lines, then fills in horizontal divisions within each section\n * @param {number} gridSize - Size of the grid\n * @param {Set} walls - Current walls set\n * @param {Set} mazeGenerationCells - Cells being processed\n * @param {Function} updateWalls - Callback to update walls\n * @param {Function} updateMazeGeneration - Callback to update generation cells\n * @param {number} animationSpeed - Animation delay\n * @param {Function} incrementSteps - Callback to increment step counter\n */\nasync function createSystematicDivisions(\n  gridSize,\n  walls, mazeGenerationCells,\n  updateWalls, updateMazeGeneration,\n  animationSpeed, incrementSteps\n) {\n  const sections = [];\n  \n  // Step 1: Create vertical divisions first (top-to-bottom lines)\n  const numVerticalDivisions = Math.floor((gridSize - 2) / 4); // Create divisions every 4 cells\n  \n  for (let i = 1; i <= numVerticalDivisions; i++) {\n    const wallCol = 1 + (i * Math.floor((gridSize - 2) / (numVerticalDivisions + 1)));\n    \n    // Create full vertical line from top to bottom\n    await createVerticalWall(\n      wallCol, 1, gridSize - 2,\n      walls, mazeGenerationCells,\n      updateWalls, updateMazeGeneration,\n      animationSpeed, incrementSteps\n    );\n  }\n  \n  // Step 2: Define sections created by vertical walls\n  let sectionStart = 1;\n  for (let i = 0; i <= numVerticalDivisions; i++) {\n    let sectionEnd;\n    if (i === numVerticalDivisions) {\n      sectionEnd = gridSize - 1;\n    } else {\n      sectionEnd = 1 + ((i + 1) * Math.floor((gridSize - 2) / (numVerticalDivisions + 1)));\n    }\n    \n    sections.push({\n      startCol: sectionStart,\n      endCol: sectionEnd - 1,\n      startRow: 1,\n      endRow: gridSize - 1\n    });\n    \n    sectionStart = sectionEnd + 1;\n  }\n  \n  // Step 3: Fill each section with horizontal divisions\n  for (const section of sections) {\n    await fillSectionWithHorizontalDivisions(\n      section,\n      walls, mazeGenerationCells,\n      updateWalls, updateMazeGeneration,\n      animationSpeed, incrementSteps\n    );\n  }\n}\n\n/**\n * Create a vertical wall from top to bottom with a random passage\n */\nasync function createVerticalWall(\n  wallCol, startRow, height,\n  walls, mazeGenerationCells,\n  updateWalls, updateMazeGeneration,\n  animationSpeed, incrementSteps\n) {\n  // Choose a random position for the passage\n  const passageRow = startRow + Math.floor(Math.random() * height);\n  \n  // Add vertical wall with passage\n  const newWallCells = [];\n  for (let row = startRow; row < startRow + height; row++) {\n    if (row !== passageRow) {\n      const cellKey = `${row}-${wallCol}`;\n      walls.add(cellKey);\n      mazeGenerationCells.add(cellKey);\n      newWallCells.push(cellKey);\n    }\n  }\n  \n  // Animate the wall creation\n  incrementSteps();\n  updateWalls(new Set(walls));\n  updateMazeGeneration(new Set(mazeGenerationCells));\n  await sleep(animationSpeed);\n  \n  // Remove the wall cells from generation display after a short delay\n  setTimeout(() => {\n    newWallCells.forEach(cell => mazeGenerationCells.delete(cell));\n    updateMazeGeneration(new Set(mazeGenerationCells));\n  }, animationSpeed * 1.5);\n}\n\n/**\n * Fill a section with horizontal divisions\n */\nasync function fillSectionWithHorizontalDivisions(\n  section,\n  walls, mazeGenerationCells,\n  updateWalls, updateMazeGeneration,\n  animationSpeed, incrementSteps\n) {\n  const sectionWidth = section.endCol - section.startCol + 1;\n  const sectionHeight = section.endRow - section.startRow + 1;\n  \n  // Only add horizontal divisions if section is large enough\n  if (sectionHeight < 4 || sectionWidth < 2) {\n    return;\n  }\n  \n  // Create 1-2 horizontal divisions in this section\n  const numHorizontalDivisions = Math.floor(sectionHeight / 6) || 1;\n  \n  for (let i = 1; i <= numHorizontalDivisions; i++) {\n    const wallRow = section.startRow + (i * Math.floor(sectionHeight / (numHorizontalDivisions + 1)));\n    \n    // Skip if wall would be too close to boundaries\n    if (wallRow <= section.startRow + 1 || wallRow >= section.endRow - 1) {\n      continue;\n    }\n    \n    // Choose a random position for the passage\n    const passageCol = section.startCol + Math.floor(Math.random() * sectionWidth);\n    \n    // Add horizontal wall with passage\n    const newWallCells = [];\n    for (let col = section.startCol; col <= section.endCol; col++) {\n      if (col !== passageCol) {\n        const cellKey = `${wallRow}-${col}`;\n        walls.add(cellKey);\n        mazeGenerationCells.add(cellKey);\n        newWallCells.push(cellKey);\n      }\n    }\n    \n    // Animate the wall creation\n    incrementSteps();\n    updateWalls(new Set(walls));\n    updateMazeGeneration(new Set(mazeGenerationCells));\n    await sleep(animationSpeed);\n    \n    // Remove the wall cells from generation display after a short delay\n    setTimeout(() => {\n      newWallCells.forEach(cell => mazeGenerationCells.delete(cell));\n      updateMazeGeneration(new Set(mazeGenerationCells));\n    }, animationSpeed * 1.5);\n  }\n}\n\n\n\n/**\n * Sleep function for animation delays\n */\nfunction sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n/**\n * Generate maze steps for step-by-step visualization (simplified version)\n */\nexport const getRecursiveDivisionSteps = (gridSize) => {\n  const steps = [];\n  const walls = new Set();\n  \n  // Initialize with border walls\n  for (let row = 0; row < gridSize; row++) {\n    for (let col = 0; col < gridSize; col++) {\n      if (row === 0 || row === gridSize - 1 || col === 0 || col === gridSize - 1) {\n        walls.add(`${row}-${col}`);\n      }\n    }\n  }\n  \n  steps.push({\n    walls: new Set(walls),\n    action: 'start',\n    description: 'Starting with border walls only'\n  });\n  \n  // This would contain the recursive division steps\n  // For now, return the initial step\n  return steps;\n};\n\nexport default generateMazeWithRecursiveDivision;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}