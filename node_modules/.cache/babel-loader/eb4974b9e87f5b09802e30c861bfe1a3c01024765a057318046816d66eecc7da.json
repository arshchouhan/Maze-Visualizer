{"ast":null,"code":"/**\n * Dijkstra's Algorithm Implementation\n * \n * Finds the shortest path between nodes in a graph with non-negative edge weights.\n * In this implementation, all edges have a weight of 1 (unweighted graph).\n */\n\n/**\n * Implements Dijkstra's algorithm for pathfinding\n * @param {number} gridSize - The size of the grid (gridSize x gridSize)\n * @param {Object} startPos - The starting position {row, col}\n * @param {Object} targetPos - The target position {row, col}\n * @param {Set} walls - Set of wall positions in \"row-col\" format\n * @param {Function} updateVisited - Callback to update UI with visited cells\n * @param {Function} updatePath - Callback to update UI with final path\n * @returns {Object} - Results including whether path was found, path, visited nodes count\n */\nconst dijkstra = async (gridSize, startPos, targetPos, walls, updateVisited, updatePath) => {\n  const startTime = performance.now();\n  const startPosStr = `${startPos.row}-${startPos.col}`;\n  const targetPosStr = `${targetPos.row}-${targetPos.col}`;\n\n  // Check if start is the same as target\n  if (startPosStr === targetPosStr) {\n    return {\n      pathFound: true,\n      path: [{\n        row: startPos.row,\n        col: startPos.col\n      }],\n      visitedCount: 1,\n      pathLength: 1,\n      success: true,\n      executionTime: 0\n    };\n  }\n\n  // Directions: up, right, down, left\n  const directions = [[-1, 0],\n  // up\n  [0, 1],\n  // right\n  [1, 0],\n  // down\n  [0, -1] // left\n  ];\n\n  // For visualization delay\n  const delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n  // Priority queue (min-heap) based on distance\n  const priorityQueue = [];\n  const distances = {};\n  const previous = {};\n  const visited = new Set();\n  let visitedCount = 0;\n\n  // Initialize distances\n  for (let row = 0; row < gridSize; row++) {\n    for (let col = 0; col < gridSize; col++) {\n      const pos = `${row}-${col}`;\n      distances[pos] = Infinity;\n      previous[pos] = null;\n    }\n  }\n  distances[startPosStr] = 0;\n  priorityQueue.push({\n    pos: startPosStr,\n    distance: 0\n  });\n\n  // Helper function to get unvisited neighbors\n  const getUnvisitedNeighbors = currentPos => {\n    const [row, col] = currentPos.split('-').map(Number);\n    const neighbors = [];\n    for (const [dx, dy] of directions) {\n      const newRow = row + dx;\n      const newCol = col + dy;\n      if (newRow >= 0 && newRow < gridSize && newCol >= 0 && newCol < gridSize) {\n        const neighborPos = `${newRow}-${newCol}`;\n        if (!walls.has(neighborPos) && !visited.has(neighborPos)) {\n          neighbors.push({\n            pos: neighborPos,\n            row: newRow,\n            col: newCol,\n            distance: 1 // All edges have weight of 1 in an unweighted grid\n          });\n        }\n      }\n    }\n    return neighbors;\n  };\n\n  // Main algorithm loop\n  while (priorityQueue.length > 0) {\n    // Sort the priority queue (simple implementation, could be optimized with a proper priority queue)\n    priorityQueue.sort((a, b) => a.distance - b.distance);\n    const {\n      pos: currentPos,\n      distance\n    } = priorityQueue.shift();\n\n    // Skip if we've already processed this node\n    if (visited.has(currentPos)) continue;\n\n    // Mark as visited\n    visited.add(currentPos);\n    visitedCount++;\n\n    // Update UI for visited cell (except start position)\n    if (currentPos !== startPosStr) {\n      const [row, col] = currentPos.split('-').map(Number);\n      if (updateVisited) {\n        updateVisited(row, col);\n        // Only delay every 3rd cell for better performance\n        if (visitedCount % 3 === 0) {\n          await delay(1);\n        }\n      }\n    }\n\n    // Check if we've reached the target\n    if (currentPos === targetPosStr) {\n      break;\n    }\n\n    // Explore neighbors\n    const neighbors = getUnvisitedNeighbors(currentPos);\n    for (const neighbor of neighbors) {\n      const {\n        pos: neighborPos,\n        row,\n        col,\n        distance: edgeWeight\n      } = neighbor;\n\n      // Calculate new distance\n      const newDistance = distances[currentPos] + edgeWeight;\n\n      // If we found a shorter path to the neighbor\n      if (newDistance < distances[neighborPos]) {\n        distances[neighborPos] = newDistance;\n        previous[neighborPos] = currentPos;\n        priorityQueue.push({\n          pos: neighborPos,\n          distance: newDistance\n        });\n      }\n    }\n  }\n\n  // Reconstruct the path if target was found\n  const path = [];\n  let pathFound = distances[targetPosStr] !== Infinity;\n  if (pathFound) {\n    let current = targetPosStr;\n\n    // Work backward from target to start\n    while (current !== startPosStr) {\n      const [row, col] = current.split('-').map(Number);\n      path.unshift({\n        row,\n        col\n      });\n      current = previous[current];\n    }\n\n    // Update UI with the final path\n    if (updatePath) {\n      for (const {\n        row,\n        col\n      } of path) {\n        updatePath(row, col);\n        await delay(10); // Slightly longer delay for path visualization\n      }\n    }\n  }\n  const executionTime = performance.now() - startTime;\n  return {\n    pathFound,\n    path,\n    visitedCount,\n    pathLength: path.length,\n    success: pathFound,\n    executionTime\n  };\n};\nexport default dijkstra;","map":{"version":3,"names":["dijkstra","gridSize","startPos","targetPos","walls","updateVisited","updatePath","startTime","performance","now","startPosStr","row","col","targetPosStr","pathFound","path","visitedCount","pathLength","success","executionTime","directions","delay","ms","Promise","resolve","setTimeout","priorityQueue","distances","previous","visited","Set","pos","Infinity","push","distance","getUnvisitedNeighbors","currentPos","split","map","Number","neighbors","dx","dy","newRow","newCol","neighborPos","has","length","sort","a","b","shift","add","neighbor","edgeWeight","newDistance","current","unshift"],"sources":["E:/maze_analyser/src/algorithms/dijkstra.js"],"sourcesContent":["/**\n * Dijkstra's Algorithm Implementation\n * \n * Finds the shortest path between nodes in a graph with non-negative edge weights.\n * In this implementation, all edges have a weight of 1 (unweighted graph).\n */\n\n/**\n * Implements Dijkstra's algorithm for pathfinding\n * @param {number} gridSize - The size of the grid (gridSize x gridSize)\n * @param {Object} startPos - The starting position {row, col}\n * @param {Object} targetPos - The target position {row, col}\n * @param {Set} walls - Set of wall positions in \"row-col\" format\n * @param {Function} updateVisited - Callback to update UI with visited cells\n * @param {Function} updatePath - Callback to update UI with final path\n * @returns {Object} - Results including whether path was found, path, visited nodes count\n */\nconst dijkstra = async (\n  gridSize,\n  startPos,\n  targetPos,\n  walls,\n  updateVisited,\n  updatePath\n) => {\n  const startTime = performance.now();\n  const startPosStr = `${startPos.row}-${startPos.col}`;\n  const targetPosStr = `${targetPos.row}-${targetPos.col}`;\n  \n  // Check if start is the same as target\n  if (startPosStr === targetPosStr) {\n    return {\n      pathFound: true,\n      path: [{ row: startPos.row, col: startPos.col }],\n      visitedCount: 1,\n      pathLength: 1,\n      success: true,\n      executionTime: 0\n    };\n  }\n\n  // Directions: up, right, down, left\n  const directions = [\n    [-1, 0], // up\n    [0, 1],  // right\n    [1, 0],  // down\n    [0, -1]  // left\n  ];\n\n  // For visualization delay\n  const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));\n\n  // Priority queue (min-heap) based on distance\n  const priorityQueue = [];\n  const distances = {};\n  const previous = {};\n  const visited = new Set();\n  let visitedCount = 0;\n\n  // Initialize distances\n  for (let row = 0; row < gridSize; row++) {\n    for (let col = 0; col < gridSize; col++) {\n      const pos = `${row}-${col}`;\n      distances[pos] = Infinity;\n      previous[pos] = null;\n    }\n  }\n  distances[startPosStr] = 0;\n  priorityQueue.push({ pos: startPosStr, distance: 0 });\n\n  // Helper function to get unvisited neighbors\n  const getUnvisitedNeighbors = (currentPos) => {\n    const [row, col] = currentPos.split('-').map(Number);\n    const neighbors = [];\n\n    for (const [dx, dy] of directions) {\n      const newRow = row + dx;\n      const newCol = col + dy;\n      \n      if (newRow >= 0 && newRow < gridSize && newCol >= 0 && newCol < gridSize) {\n        const neighborPos = `${newRow}-${newCol}`;\n        if (!walls.has(neighborPos) && !visited.has(neighborPos)) {\n          neighbors.push({\n            pos: neighborPos,\n            row: newRow,\n            col: newCol,\n            distance: 1 // All edges have weight of 1 in an unweighted grid\n          });\n        }\n      }\n    }\n\n    return neighbors;\n  };\n\n  // Main algorithm loop\n  while (priorityQueue.length > 0) {\n    // Sort the priority queue (simple implementation, could be optimized with a proper priority queue)\n    priorityQueue.sort((a, b) => a.distance - b.distance);\n    const { pos: currentPos, distance } = priorityQueue.shift();\n\n    // Skip if we've already processed this node\n    if (visited.has(currentPos)) continue;\n    \n    // Mark as visited\n    visited.add(currentPos);\n    visitedCount++;\n\n    // Update UI for visited cell (except start position)\n    if (currentPos !== startPosStr) {\n      const [row, col] = currentPos.split('-').map(Number);\n      if (updateVisited) {\n        updateVisited(row, col);\n        // Only delay every 3rd cell for better performance\n        if (visitedCount % 3 === 0) {\n          await delay(1);\n        }\n      }\n    }\n\n    // Check if we've reached the target\n    if (currentPos === targetPosStr) {\n      break;\n    }\n\n    // Explore neighbors\n    const neighbors = getUnvisitedNeighbors(currentPos);\n    for (const neighbor of neighbors) {\n      const { pos: neighborPos, row, col, distance: edgeWeight } = neighbor;\n      \n      // Calculate new distance\n      const newDistance = distances[currentPos] + edgeWeight;\n      \n      // If we found a shorter path to the neighbor\n      if (newDistance < distances[neighborPos]) {\n        distances[neighborPos] = newDistance;\n        previous[neighborPos] = currentPos;\n        priorityQueue.push({ pos: neighborPos, distance: newDistance });\n      }\n    }\n  }\n\n  // Reconstruct the path if target was found\n  const path = [];\n  let pathFound = distances[targetPosStr] !== Infinity;\n  \n  if (pathFound) {\n    let current = targetPosStr;\n    \n    // Work backward from target to start\n    while (current !== startPosStr) {\n      const [row, col] = current.split('-').map(Number);\n      path.unshift({ row, col });\n      current = previous[current];\n    }\n    \n    // Update UI with the final path\n    if (updatePath) {\n      for (const { row, col } of path) {\n        updatePath(row, col);\n        await delay(10); // Slightly longer delay for path visualization\n      }\n    }\n  }\n\n  const executionTime = performance.now() - startTime;\n  \n  return {\n    pathFound,\n    path,\n    visitedCount,\n    pathLength: path.length,\n    success: pathFound,\n    executionTime\n  };\n};\n\nexport default dijkstra;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}