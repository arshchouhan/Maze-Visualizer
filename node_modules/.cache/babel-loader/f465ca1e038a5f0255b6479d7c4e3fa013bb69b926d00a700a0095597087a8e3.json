{"ast":null,"code":"/**\n * Prim's Algorithm for Maze Generation\n * \n * This algorithm generates a maze by starting with a grid full of walls and \n * carving out passages using Prim's minimum spanning tree algorithm.\n * \n * Data Structures Used:\n * - Set: For tracking visited cells and walls\n * - Array: For frontier walls (acts as a priority queue)\n * - Map: For parent tracking during generation\n */\n\n/**\n * Priority Queue implementation using array for Prim's algorithm\n */\nclass PriorityQueue {\n  constructor() {\n    this.items = [];\n  }\n  enqueue(element, priority = Math.random()) {\n    const queueElement = {\n      element,\n      priority\n    };\n    let added = false;\n    for (let i = 0; i < this.items.length; i++) {\n      if (queueElement.priority < this.items[i].priority) {\n        this.items.splice(i, 0, queueElement);\n        added = true;\n        break;\n      }\n    }\n    if (!added) {\n      this.items.push(queueElement);\n    }\n  }\n  dequeue() {\n    var _this$items$shift;\n    return (_this$items$shift = this.items.shift()) === null || _this$items$shift === void 0 ? void 0 : _this$items$shift.element;\n  }\n  isEmpty() {\n    return this.items.length === 0;\n  }\n  size() {\n    return this.items.length;\n  }\n}\n\n/**\n * Generates a maze using Prim's algorithm with animation\n * @param {number} gridSize - The size of the grid (gridSize x gridSize)\n * @param {Function} updateWalls - Callback to update UI with current walls\n * @param {Function} updateVisited - Callback to update UI with visited cells\n * @param {number} animationSpeed - Speed of animation in milliseconds\n * @returns {Object} - Results including final walls set and generation stats\n */\nexport const generateMazeWithPrims = async (gridSize, updateWalls, updateVisited, animationSpeed = 50) => {\n  // Initialize all cells as walls\n  const walls = new Set();\n  const visited = new Set();\n  const frontierWalls = new PriorityQueue();\n\n  // Fill entire grid with walls initially\n  for (let row = 0; row < gridSize; row++) {\n    for (let col = 0; col < gridSize; col++) {\n      walls.add(`${row}-${col}`);\n    }\n  }\n\n  // Start from a random cell (preferably odd coordinates for better maze structure)\n  const startRow = 1 + Math.floor(Math.random() * (gridSize - 2));\n  const startCol = 1 + Math.floor(Math.random() * (gridSize - 2));\n  const startCell = `${startRow}-${startCol}`;\n\n  // Mark starting cell as passage (remove from walls)\n  walls.delete(startCell);\n  visited.add(startCell);\n\n  // Add frontier walls of the starting cell\n  addFrontierWalls(startRow, startCol, gridSize, walls, visited, frontierWalls);\n  let generationSteps = 0;\n\n  // Update initial state\n  updateWalls(new Set(walls));\n  updateVisited(new Set([startCell]));\n  await sleep(animationSpeed);\n\n  // Main Prim's algorithm loop\n  while (!frontierWalls.isEmpty()) {\n    // Pick a random frontier wall\n    const currentWall = frontierWalls.dequeue();\n    if (!currentWall) break;\n    const [wallRow, wallCol] = currentWall.split('-').map(Number);\n    const wallKey = `${wallRow}-${wallCol}`;\n\n    // Skip if this wall is already processed\n    if (!walls.has(wallKey)) continue;\n\n    // Find adjacent passage cells\n    const adjacentPassages = getAdjacentPassages(wallRow, wallCol, gridSize, walls);\n    if (adjacentPassages.length > 0) {\n      // Make this wall a passage\n      walls.delete(wallKey);\n      visited.add(wallKey);\n\n      // Add new frontier walls\n      addFrontierWalls(wallRow, wallCol, gridSize, walls, visited, frontierWalls);\n      generationSteps++;\n\n      // Update UI with animation\n      updateWalls(new Set(walls));\n      updateVisited(new Set(visited));\n      await sleep(animationSpeed);\n    }\n  }\n\n  // Clean up the maze by ensuring proper wall structure\n  const finalWalls = cleanupMaze(walls, gridSize);\n  updateWalls(finalWalls);\n  return {\n    walls: finalWalls,\n    generationSteps,\n    visitedCells: visited.size\n  };\n};\n\n/**\n * Add frontier walls around a given cell\n */\nfunction addFrontierWalls(row, col, gridSize, walls, visited, frontierWalls) {\n  const directions = [[-1, 0], [1, 0], [0, -1], [0, 1] // up, down, left, right\n  ];\n  directions.forEach(([dRow, dCol]) => {\n    const newRow = row + dRow;\n    const newCol = col + dCol;\n    const cellKey = `${newRow}-${newCol}`;\n\n    // Check bounds and if it's a wall that hasn't been visited\n    if (newRow >= 0 && newRow < gridSize && newCol >= 0 && newCol < gridSize && walls.has(cellKey) && !visited.has(cellKey)) {\n      frontierWalls.enqueue(cellKey, Math.random());\n    }\n  });\n}\n\n/**\n * Get adjacent passage cells (cells that are not walls)\n */\nfunction getAdjacentPassages(row, col, gridSize, walls) {\n  const directions = [[-1, 0], [1, 0], [0, -1], [0, 1] // up, down, left, right\n  ];\n  const passages = [];\n  directions.forEach(([dRow, dCol]) => {\n    const newRow = row + dRow;\n    const newCol = col + dCol;\n    const cellKey = `${newRow}-${newCol}`;\n\n    // Check bounds and if it's a passage (not a wall)\n    if (newRow >= 0 && newRow < gridSize && newCol >= 0 && newCol < gridSize && !walls.has(cellKey)) {\n      passages.push(cellKey);\n    }\n  });\n  return passages;\n}\n\n/**\n * Clean up the maze to ensure proper structure\n */\nfunction cleanupMaze(walls, gridSize) {\n  const finalWalls = new Set(walls);\n\n  // Ensure border walls\n  for (let i = 0; i < gridSize; i++) {\n    finalWalls.add(`0-${i}`); // Top border\n    finalWalls.add(`${gridSize - 1}-${i}`); // Bottom border\n    finalWalls.add(`${i}-0`); // Left border\n    finalWalls.add(`${i}-${gridSize - 1}`); // Right border\n  }\n  return finalWalls;\n}\n\n/**\n * Sleep function for animation delays\n */\nfunction sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n/**\n * Generate maze steps for step-by-step visualization\n * Returns an array of steps that can be played back\n */\nexport const getPrimsMazeSteps = gridSize => {\n  const steps = [];\n  const walls = new Set();\n  const visited = new Set();\n  const frontierWalls = new PriorityQueue();\n\n  // Initialize all cells as walls\n  for (let row = 0; row < gridSize; row++) {\n    for (let col = 0; col < gridSize; col++) {\n      walls.add(`${row}-${col}`);\n    }\n  }\n\n  // Start from center or random position\n  const startRow = Math.floor(gridSize / 2);\n  const startCol = Math.floor(gridSize / 2);\n  const startCell = `${startRow}-${startCol}`;\n  walls.delete(startCell);\n  visited.add(startCell);\n  addFrontierWalls(startRow, startCol, gridSize, walls, visited, frontierWalls);\n  steps.push({\n    walls: new Set(walls),\n    visited: new Set(visited),\n    action: 'start',\n    cell: startCell\n  });\n\n  // Generate steps\n  while (!frontierWalls.isEmpty()) {\n    const currentWall = frontierWalls.dequeue();\n    if (!currentWall) break;\n    const [wallRow, wallCol] = currentWall.split('-').map(Number);\n    const wallKey = `${wallRow}-${wallCol}`;\n    if (!walls.has(wallKey)) continue;\n    const adjacentPassages = getAdjacentPassages(wallRow, wallCol, gridSize, walls);\n    if (adjacentPassages.length > 0) {\n      walls.delete(wallKey);\n      visited.add(wallKey);\n      addFrontierWalls(wallRow, wallCol, gridSize, walls, visited, frontierWalls);\n      steps.push({\n        walls: new Set(walls),\n        visited: new Set(visited),\n        action: 'carve',\n        cell: wallKey\n      });\n    }\n  }\n\n  // Final cleanup step\n  const finalWalls = cleanupMaze(walls, gridSize);\n  steps.push({\n    walls: finalWalls,\n    visited: new Set(visited),\n    action: 'complete',\n    cell: null\n  });\n  return steps;\n};\nexport default generateMazeWithPrims;","map":{"version":3,"names":["PriorityQueue","constructor","items","enqueue","element","priority","Math","random","queueElement","added","i","length","splice","push","dequeue","_this$items$shift","shift","isEmpty","size","generateMazeWithPrims","gridSize","updateWalls","updateVisited","animationSpeed","walls","Set","visited","frontierWalls","row","col","add","startRow","floor","startCol","startCell","delete","addFrontierWalls","generationSteps","sleep","currentWall","wallRow","wallCol","split","map","Number","wallKey","has","adjacentPassages","getAdjacentPassages","finalWalls","cleanupMaze","visitedCells","directions","forEach","dRow","dCol","newRow","newCol","cellKey","passages","ms","Promise","resolve","setTimeout","getPrimsMazeSteps","steps","action","cell"],"sources":["E:/maze_analyser/src/algorithms/primsAlgorithm.js"],"sourcesContent":["/**\n * Prim's Algorithm for Maze Generation\n * \n * This algorithm generates a maze by starting with a grid full of walls and \n * carving out passages using Prim's minimum spanning tree algorithm.\n * \n * Data Structures Used:\n * - Set: For tracking visited cells and walls\n * - Array: For frontier walls (acts as a priority queue)\n * - Map: For parent tracking during generation\n */\n\n/**\n * Priority Queue implementation using array for Prim's algorithm\n */\nclass PriorityQueue {\n  constructor() {\n    this.items = [];\n  }\n\n  enqueue(element, priority = Math.random()) {\n    const queueElement = { element, priority };\n    let added = false;\n\n    for (let i = 0; i < this.items.length; i++) {\n      if (queueElement.priority < this.items[i].priority) {\n        this.items.splice(i, 0, queueElement);\n        added = true;\n        break;\n      }\n    }\n\n    if (!added) {\n      this.items.push(queueElement);\n    }\n  }\n\n  dequeue() {\n    return this.items.shift()?.element;\n  }\n\n  isEmpty() {\n    return this.items.length === 0;\n  }\n\n  size() {\n    return this.items.length;\n  }\n}\n\n/**\n * Generates a maze using Prim's algorithm with animation\n * @param {number} gridSize - The size of the grid (gridSize x gridSize)\n * @param {Function} updateWalls - Callback to update UI with current walls\n * @param {Function} updateVisited - Callback to update UI with visited cells\n * @param {number} animationSpeed - Speed of animation in milliseconds\n * @returns {Object} - Results including final walls set and generation stats\n */\nexport const generateMazeWithPrims = async (\n  gridSize,\n  updateWalls,\n  updateVisited,\n  animationSpeed = 50\n) => {\n  // Initialize all cells as walls\n  const walls = new Set();\n  const visited = new Set();\n  const frontierWalls = new PriorityQueue();\n  \n  // Fill entire grid with walls initially\n  for (let row = 0; row < gridSize; row++) {\n    for (let col = 0; col < gridSize; col++) {\n      walls.add(`${row}-${col}`);\n    }\n  }\n\n  // Start from a random cell (preferably odd coordinates for better maze structure)\n  const startRow = 1 + Math.floor(Math.random() * (gridSize - 2));\n  const startCol = 1 + Math.floor(Math.random() * (gridSize - 2));\n  const startCell = `${startRow}-${startCol}`;\n  \n  // Mark starting cell as passage (remove from walls)\n  walls.delete(startCell);\n  visited.add(startCell);\n  \n  // Add frontier walls of the starting cell\n  addFrontierWalls(startRow, startCol, gridSize, walls, visited, frontierWalls);\n  \n  let generationSteps = 0;\n  \n  // Update initial state\n  updateWalls(new Set(walls));\n  updateVisited(new Set([startCell]));\n  await sleep(animationSpeed);\n\n  // Main Prim's algorithm loop\n  while (!frontierWalls.isEmpty()) {\n    // Pick a random frontier wall\n    const currentWall = frontierWalls.dequeue();\n    if (!currentWall) break;\n    \n    const [wallRow, wallCol] = currentWall.split('-').map(Number);\n    const wallKey = `${wallRow}-${wallCol}`;\n    \n    // Skip if this wall is already processed\n    if (!walls.has(wallKey)) continue;\n    \n    // Find adjacent passage cells\n    const adjacentPassages = getAdjacentPassages(wallRow, wallCol, gridSize, walls);\n    \n    if (adjacentPassages.length > 0) {\n      // Make this wall a passage\n      walls.delete(wallKey);\n      visited.add(wallKey);\n      \n      // Add new frontier walls\n      addFrontierWalls(wallRow, wallCol, gridSize, walls, visited, frontierWalls);\n      \n      generationSteps++;\n      \n      // Update UI with animation\n      updateWalls(new Set(walls));\n      updateVisited(new Set(visited));\n      await sleep(animationSpeed);\n    }\n  }\n\n  // Clean up the maze by ensuring proper wall structure\n  const finalWalls = cleanupMaze(walls, gridSize);\n  \n  updateWalls(finalWalls);\n  \n  return {\n    walls: finalWalls,\n    generationSteps,\n    visitedCells: visited.size\n  };\n};\n\n/**\n * Add frontier walls around a given cell\n */\nfunction addFrontierWalls(row, col, gridSize, walls, visited, frontierWalls) {\n  const directions = [\n    [-1, 0], [1, 0], [0, -1], [0, 1] // up, down, left, right\n  ];\n  \n  directions.forEach(([dRow, dCol]) => {\n    const newRow = row + dRow;\n    const newCol = col + dCol;\n    const cellKey = `${newRow}-${newCol}`;\n    \n    // Check bounds and if it's a wall that hasn't been visited\n    if (\n      newRow >= 0 && newRow < gridSize &&\n      newCol >= 0 && newCol < gridSize &&\n      walls.has(cellKey) &&\n      !visited.has(cellKey)\n    ) {\n      frontierWalls.enqueue(cellKey, Math.random());\n    }\n  });\n}\n\n/**\n * Get adjacent passage cells (cells that are not walls)\n */\nfunction getAdjacentPassages(row, col, gridSize, walls) {\n  const directions = [\n    [-1, 0], [1, 0], [0, -1], [0, 1] // up, down, left, right\n  ];\n  const passages = [];\n  \n  directions.forEach(([dRow, dCol]) => {\n    const newRow = row + dRow;\n    const newCol = col + dCol;\n    const cellKey = `${newRow}-${newCol}`;\n    \n    // Check bounds and if it's a passage (not a wall)\n    if (\n      newRow >= 0 && newRow < gridSize &&\n      newCol >= 0 && newCol < gridSize &&\n      !walls.has(cellKey)\n    ) {\n      passages.push(cellKey);\n    }\n  });\n  \n  return passages;\n}\n\n/**\n * Clean up the maze to ensure proper structure\n */\nfunction cleanupMaze(walls, gridSize) {\n  const finalWalls = new Set(walls);\n  \n  // Ensure border walls\n  for (let i = 0; i < gridSize; i++) {\n    finalWalls.add(`0-${i}`); // Top border\n    finalWalls.add(`${gridSize - 1}-${i}`); // Bottom border\n    finalWalls.add(`${i}-0`); // Left border\n    finalWalls.add(`${i}-${gridSize - 1}`); // Right border\n  }\n  \n  return finalWalls;\n}\n\n/**\n * Sleep function for animation delays\n */\nfunction sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n/**\n * Generate maze steps for step-by-step visualization\n * Returns an array of steps that can be played back\n */\nexport const getPrimsMazeSteps = (gridSize) => {\n  const steps = [];\n  const walls = new Set();\n  const visited = new Set();\n  const frontierWalls = new PriorityQueue();\n  \n  // Initialize all cells as walls\n  for (let row = 0; row < gridSize; row++) {\n    for (let col = 0; col < gridSize; col++) {\n      walls.add(`${row}-${col}`);\n    }\n  }\n\n  // Start from center or random position\n  const startRow = Math.floor(gridSize / 2);\n  const startCol = Math.floor(gridSize / 2);\n  const startCell = `${startRow}-${startCol}`;\n  \n  walls.delete(startCell);\n  visited.add(startCell);\n  addFrontierWalls(startRow, startCol, gridSize, walls, visited, frontierWalls);\n  \n  steps.push({\n    walls: new Set(walls),\n    visited: new Set(visited),\n    action: 'start',\n    cell: startCell\n  });\n\n  // Generate steps\n  while (!frontierWalls.isEmpty()) {\n    const currentWall = frontierWalls.dequeue();\n    if (!currentWall) break;\n    \n    const [wallRow, wallCol] = currentWall.split('-').map(Number);\n    const wallKey = `${wallRow}-${wallCol}`;\n    \n    if (!walls.has(wallKey)) continue;\n    \n    const adjacentPassages = getAdjacentPassages(wallRow, wallCol, gridSize, walls);\n    \n    if (adjacentPassages.length > 0) {\n      walls.delete(wallKey);\n      visited.add(wallKey);\n      addFrontierWalls(wallRow, wallCol, gridSize, walls, visited, frontierWalls);\n      \n      steps.push({\n        walls: new Set(walls),\n        visited: new Set(visited),\n        action: 'carve',\n        cell: wallKey\n      });\n    }\n  }\n\n  // Final cleanup step\n  const finalWalls = cleanupMaze(walls, gridSize);\n  steps.push({\n    walls: finalWalls,\n    visited: new Set(visited),\n    action: 'complete',\n    cell: null\n  });\n\n  return steps;\n};\n\nexport default generateMazeWithPrims;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}