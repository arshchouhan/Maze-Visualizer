{"ast":null,"code":"/**\n * Prim's Algorithm for Maze Generation\n * \n * This algorithm generates a maze by starting with a grid full of walls and \n * carving out passages using Prim's minimum spanning tree algorithm.\n * \n * Data Structures Used:\n * - Set: For tracking visited cells and walls\n * - Array: For frontier walls (acts as a priority queue)\n * - Map: For parent tracking during generation\n */\n\n/**\n * Priority Queue implementation using array for Prim's algorithm\n */\nclass PriorityQueue {\n  constructor() {\n    this.items = [];\n  }\n  enqueue(element, priority = Math.random()) {\n    const queueElement = {\n      element,\n      priority\n    };\n    let added = false;\n    for (let i = 0; i < this.items.length; i++) {\n      if (queueElement.priority < this.items[i].priority) {\n        this.items.splice(i, 0, queueElement);\n        added = true;\n        break;\n      }\n    }\n    if (!added) {\n      this.items.push(queueElement);\n    }\n  }\n  dequeue() {\n    var _this$items$shift;\n    return (_this$items$shift = this.items.shift()) === null || _this$items$shift === void 0 ? void 0 : _this$items$shift.element;\n  }\n  isEmpty() {\n    return this.items.length === 0;\n  }\n  size() {\n    return this.items.length;\n  }\n}\n\n/**\n * Generates a maze using Prim's algorithm with animation\n * @param {number} gridSize - The size of the grid (gridSize x gridSize)\n * @param {Function} updateWalls - Callback to update UI with current walls\n * @param {Function} updateMazeGeneration - Callback to update UI with maze generation cells\n * @param {number} animationSpeed - Speed of animation in milliseconds\n * @returns {Object} - Results including final walls set and generation stats\n */\nexport const generateMazeWithPrims = async (gridSize, updateWalls, updateMazeGeneration, animationSpeed = 100) => {\n  // Initialize: Start with all cells as walls except borders\n  const walls = new Set();\n  const passages = new Set();\n  const frontierCells = [];\n  const mazeGenerationCells = new Set();\n\n  // Create border walls and fill interior with walls\n  for (let row = 0; row < gridSize; row++) {\n    for (let col = 0; col < gridSize; col++) {\n      // Always make borders walls\n      if (row === 0 || row === gridSize - 1 || col === 0 || col === gridSize - 1) {\n        walls.add(`${row}-${col}`);\n      } else {\n        // Interior starts as walls too\n        walls.add(`${row}-${col}`);\n      }\n    }\n  }\n\n  // Pick a random starting cell (not on border)\n  const startRow = 2 + Math.floor(Math.random() * (gridSize - 4));\n  const startCol = 2 + Math.floor(Math.random() * (gridSize - 4));\n  const startCell = `${startRow}-${startCol}`;\n\n  // Make starting cell a passage\n  walls.delete(startCell);\n  passages.add(startCell);\n\n  // Add neighbors of starting cell to frontier\n  addNeighborsToFrontier(startRow, startCol, gridSize, walls, passages, frontierCells);\n  let generationSteps = 0;\n\n  // Update initial state\n  updateWalls(new Set(walls));\n  updateMazeGeneration(new Set([startCell]));\n  await sleep(animationSpeed);\n\n  // Main Prim's algorithm loop\n  while (frontierCells.length > 0) {\n    // Pick a random frontier cell\n    const randomIndex = Math.floor(Math.random() * frontierCells.length);\n    const [currentRow, currentCol] = frontierCells.splice(randomIndex, 1)[0];\n    const currentCell = `${currentRow}-${currentCol}`;\n\n    // Skip if this cell is already a passage\n    if (passages.has(currentCell)) continue;\n\n    // Find adjacent passage cells\n    const adjacentPassages = getAdjacentPassageCells(currentRow, currentCol, gridSize, passages);\n    if (adjacentPassages.length > 0) {\n      // Make this cell a passage\n      walls.delete(currentCell);\n      passages.add(currentCell);\n      mazeGenerationCells.add(currentCell);\n\n      // Connect to one of the adjacent passages by carving a path\n      const connectTo = adjacentPassages[Math.floor(Math.random() * adjacentPassages.length)];\n      const [connectRow, connectCol] = connectTo.split('-').map(Number);\n\n      // Carve the connecting wall if needed\n      const midRow = Math.floor((currentRow + connectRow) / 2);\n      const midCol = Math.floor((currentCol + connectCol) / 2);\n      const midCell = `${midRow}-${midCol}`;\n      if (walls.has(midCell)) {\n        walls.delete(midCell);\n        passages.add(midCell);\n        mazeGenerationCells.add(midCell);\n      }\n\n      // Add new frontier cells\n      addNeighborsToFrontier(currentRow, currentCol, gridSize, walls, passages, frontierCells);\n      generationSteps++;\n\n      // Update UI with animation\n      updateWalls(new Set(walls));\n      updateMazeGeneration(new Set(mazeGenerationCells));\n      await sleep(animationSpeed);\n    }\n  }\n\n  // Clear maze generation cells after a delay\n  setTimeout(() => {\n    updateMazeGeneration(new Set());\n  }, 1500);\n  return {\n    walls: new Set(walls),\n    generationSteps,\n    visitedCells: passages.size\n  };\n};\n\n/**\n * Add frontier walls around a given cell\n */\nfunction addFrontierWalls(row, col, gridSize, walls, visited, frontierWalls) {\n  const directions = [[-1, 0], [1, 0], [0, -1], [0, 1] // up, down, left, right\n  ];\n  directions.forEach(([dRow, dCol]) => {\n    const newRow = row + dRow;\n    const newCol = col + dCol;\n    const cellKey = `${newRow}-${newCol}`;\n\n    // Check bounds and if it's a wall that hasn't been visited\n    if (newRow >= 0 && newRow < gridSize && newCol >= 0 && newCol < gridSize && walls.has(cellKey) && !visited.has(cellKey)) {\n      frontierWalls.enqueue(cellKey, Math.random());\n    }\n  });\n}\n\n/**\n * Get adjacent passage cells (cells that are not walls)\n */\nfunction getAdjacentPassages(row, col, gridSize, walls) {\n  const directions = [[-1, 0], [1, 0], [0, -1], [0, 1] // up, down, left, right\n  ];\n  const passages = [];\n  directions.forEach(([dRow, dCol]) => {\n    const newRow = row + dRow;\n    const newCol = col + dCol;\n    const cellKey = `${newRow}-${newCol}`;\n\n    // Check bounds and if it's a passage (not a wall)\n    if (newRow >= 0 && newRow < gridSize && newCol >= 0 && newCol < gridSize && !walls.has(cellKey)) {\n      passages.push(cellKey);\n    }\n  });\n  return passages;\n}\n\n/**\n * Clean up the maze to ensure proper structure\n */\nfunction cleanupMaze(walls, gridSize) {\n  const finalWalls = new Set(walls);\n\n  // Ensure border walls\n  for (let i = 0; i < gridSize; i++) {\n    finalWalls.add(`0-${i}`); // Top border\n    finalWalls.add(`${gridSize - 1}-${i}`); // Bottom border\n    finalWalls.add(`${i}-0`); // Left border\n    finalWalls.add(`${i}-${gridSize - 1}`); // Right border\n  }\n  return finalWalls;\n}\n\n/**\n * Sleep function for animation delays\n */\nfunction sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n/**\n * Generate maze steps for step-by-step visualization\n * Returns an array of steps that can be played back\n */\nexport const getPrimsMazeSteps = gridSize => {\n  const steps = [];\n  const walls = new Set();\n  const visited = new Set();\n  const frontierWalls = new PriorityQueue();\n\n  // Initialize all cells as walls\n  for (let row = 0; row < gridSize; row++) {\n    for (let col = 0; col < gridSize; col++) {\n      walls.add(`${row}-${col}`);\n    }\n  }\n\n  // Start from center or random position\n  const startRow = Math.floor(gridSize / 2);\n  const startCol = Math.floor(gridSize / 2);\n  const startCell = `${startRow}-${startCol}`;\n  walls.delete(startCell);\n  visited.add(startCell);\n  addFrontierWalls(startRow, startCol, gridSize, walls, visited, frontierWalls);\n  steps.push({\n    walls: new Set(walls),\n    visited: new Set(visited),\n    action: 'start',\n    cell: startCell\n  });\n\n  // Generate steps\n  while (!frontierWalls.isEmpty()) {\n    const currentWall = frontierWalls.dequeue();\n    if (!currentWall) break;\n    const [wallRow, wallCol] = currentWall.split('-').map(Number);\n    const wallKey = `${wallRow}-${wallCol}`;\n    if (!walls.has(wallKey)) continue;\n    const adjacentPassages = getAdjacentPassages(wallRow, wallCol, gridSize, walls);\n    if (adjacentPassages.length > 0) {\n      walls.delete(wallKey);\n      visited.add(wallKey);\n      addFrontierWalls(wallRow, wallCol, gridSize, walls, visited, frontierWalls);\n      steps.push({\n        walls: new Set(walls),\n        visited: new Set(visited),\n        action: 'carve',\n        cell: wallKey\n      });\n    }\n  }\n\n  // Final cleanup step\n  const finalWalls = cleanupMaze(walls, gridSize);\n  steps.push({\n    walls: finalWalls,\n    visited: new Set(visited),\n    action: 'complete',\n    cell: null\n  });\n  return steps;\n};\nexport default generateMazeWithPrims;","map":{"version":3,"names":["PriorityQueue","constructor","items","enqueue","element","priority","Math","random","queueElement","added","i","length","splice","push","dequeue","_this$items$shift","shift","isEmpty","size","generateMazeWithPrims","gridSize","updateWalls","updateMazeGeneration","animationSpeed","walls","Set","passages","frontierCells","mazeGenerationCells","row","col","add","startRow","floor","startCol","startCell","delete","addNeighborsToFrontier","generationSteps","sleep","randomIndex","currentRow","currentCol","currentCell","has","adjacentPassages","getAdjacentPassageCells","connectTo","connectRow","connectCol","split","map","Number","midRow","midCol","midCell","setTimeout","visitedCells","addFrontierWalls","visited","frontierWalls","directions","forEach","dRow","dCol","newRow","newCol","cellKey","getAdjacentPassages","cleanupMaze","finalWalls","ms","Promise","resolve","getPrimsMazeSteps","steps","action","cell","currentWall","wallRow","wallCol","wallKey"],"sources":["E:/maze_analyser/src/algorithms/primsAlgorithm.js"],"sourcesContent":["/**\n * Prim's Algorithm for Maze Generation\n * \n * This algorithm generates a maze by starting with a grid full of walls and \n * carving out passages using Prim's minimum spanning tree algorithm.\n * \n * Data Structures Used:\n * - Set: For tracking visited cells and walls\n * - Array: For frontier walls (acts as a priority queue)\n * - Map: For parent tracking during generation\n */\n\n/**\n * Priority Queue implementation using array for Prim's algorithm\n */\nclass PriorityQueue {\n  constructor() {\n    this.items = [];\n  }\n\n  enqueue(element, priority = Math.random()) {\n    const queueElement = { element, priority };\n    let added = false;\n\n    for (let i = 0; i < this.items.length; i++) {\n      if (queueElement.priority < this.items[i].priority) {\n        this.items.splice(i, 0, queueElement);\n        added = true;\n        break;\n      }\n    }\n\n    if (!added) {\n      this.items.push(queueElement);\n    }\n  }\n\n  dequeue() {\n    return this.items.shift()?.element;\n  }\n\n  isEmpty() {\n    return this.items.length === 0;\n  }\n\n  size() {\n    return this.items.length;\n  }\n}\n\n/**\n * Generates a maze using Prim's algorithm with animation\n * @param {number} gridSize - The size of the grid (gridSize x gridSize)\n * @param {Function} updateWalls - Callback to update UI with current walls\n * @param {Function} updateMazeGeneration - Callback to update UI with maze generation cells\n * @param {number} animationSpeed - Speed of animation in milliseconds\n * @returns {Object} - Results including final walls set and generation stats\n */\nexport const generateMazeWithPrims = async (\n  gridSize,\n  updateWalls,\n  updateMazeGeneration,\n  animationSpeed = 100\n) => {\n  // Initialize: Start with all cells as walls except borders\n  const walls = new Set();\n  const passages = new Set();\n  const frontierCells = [];\n  const mazeGenerationCells = new Set();\n  \n  // Create border walls and fill interior with walls\n  for (let row = 0; row < gridSize; row++) {\n    for (let col = 0; col < gridSize; col++) {\n      // Always make borders walls\n      if (row === 0 || row === gridSize - 1 || col === 0 || col === gridSize - 1) {\n        walls.add(`${row}-${col}`);\n      } else {\n        // Interior starts as walls too\n        walls.add(`${row}-${col}`);\n      }\n    }\n  }\n\n  // Pick a random starting cell (not on border)\n  const startRow = 2 + Math.floor(Math.random() * (gridSize - 4));\n  const startCol = 2 + Math.floor(Math.random() * (gridSize - 4));\n  const startCell = `${startRow}-${startCol}`;\n  \n  // Make starting cell a passage\n  walls.delete(startCell);\n  passages.add(startCell);\n  \n  // Add neighbors of starting cell to frontier\n  addNeighborsToFrontier(startRow, startCol, gridSize, walls, passages, frontierCells);\n  \n  let generationSteps = 0;\n  \n  // Update initial state\n  updateWalls(new Set(walls));\n  updateMazeGeneration(new Set([startCell]));\n  await sleep(animationSpeed);\n\n  // Main Prim's algorithm loop\n  while (frontierCells.length > 0) {\n    // Pick a random frontier cell\n    const randomIndex = Math.floor(Math.random() * frontierCells.length);\n    const [currentRow, currentCol] = frontierCells.splice(randomIndex, 1)[0];\n    const currentCell = `${currentRow}-${currentCol}`;\n    \n    // Skip if this cell is already a passage\n    if (passages.has(currentCell)) continue;\n    \n    // Find adjacent passage cells\n    const adjacentPassages = getAdjacentPassageCells(currentRow, currentCol, gridSize, passages);\n    \n    if (adjacentPassages.length > 0) {\n      // Make this cell a passage\n      walls.delete(currentCell);\n      passages.add(currentCell);\n      mazeGenerationCells.add(currentCell);\n      \n      // Connect to one of the adjacent passages by carving a path\n      const connectTo = adjacentPassages[Math.floor(Math.random() * adjacentPassages.length)];\n      const [connectRow, connectCol] = connectTo.split('-').map(Number);\n      \n      // Carve the connecting wall if needed\n      const midRow = Math.floor((currentRow + connectRow) / 2);\n      const midCol = Math.floor((currentCol + connectCol) / 2);\n      const midCell = `${midRow}-${midCol}`;\n      \n      if (walls.has(midCell)) {\n        walls.delete(midCell);\n        passages.add(midCell);\n        mazeGenerationCells.add(midCell);\n      }\n      \n      // Add new frontier cells\n      addNeighborsToFrontier(currentRow, currentCol, gridSize, walls, passages, frontierCells);\n      \n      generationSteps++;\n      \n      // Update UI with animation\n      updateWalls(new Set(walls));\n      updateMazeGeneration(new Set(mazeGenerationCells));\n      await sleep(animationSpeed);\n    }\n  }\n\n  // Clear maze generation cells after a delay\n  setTimeout(() => {\n    updateMazeGeneration(new Set());\n  }, 1500);\n  \n  return {\n    walls: new Set(walls),\n    generationSteps,\n    visitedCells: passages.size\n  };\n};\n\n/**\n * Add frontier walls around a given cell\n */\nfunction addFrontierWalls(row, col, gridSize, walls, visited, frontierWalls) {\n  const directions = [\n    [-1, 0], [1, 0], [0, -1], [0, 1] // up, down, left, right\n  ];\n  \n  directions.forEach(([dRow, dCol]) => {\n    const newRow = row + dRow;\n    const newCol = col + dCol;\n    const cellKey = `${newRow}-${newCol}`;\n    \n    // Check bounds and if it's a wall that hasn't been visited\n    if (\n      newRow >= 0 && newRow < gridSize &&\n      newCol >= 0 && newCol < gridSize &&\n      walls.has(cellKey) &&\n      !visited.has(cellKey)\n    ) {\n      frontierWalls.enqueue(cellKey, Math.random());\n    }\n  });\n}\n\n/**\n * Get adjacent passage cells (cells that are not walls)\n */\nfunction getAdjacentPassages(row, col, gridSize, walls) {\n  const directions = [\n    [-1, 0], [1, 0], [0, -1], [0, 1] // up, down, left, right\n  ];\n  const passages = [];\n  \n  directions.forEach(([dRow, dCol]) => {\n    const newRow = row + dRow;\n    const newCol = col + dCol;\n    const cellKey = `${newRow}-${newCol}`;\n    \n    // Check bounds and if it's a passage (not a wall)\n    if (\n      newRow >= 0 && newRow < gridSize &&\n      newCol >= 0 && newCol < gridSize &&\n      !walls.has(cellKey)\n    ) {\n      passages.push(cellKey);\n    }\n  });\n  \n  return passages;\n}\n\n/**\n * Clean up the maze to ensure proper structure\n */\nfunction cleanupMaze(walls, gridSize) {\n  const finalWalls = new Set(walls);\n  \n  // Ensure border walls\n  for (let i = 0; i < gridSize; i++) {\n    finalWalls.add(`0-${i}`); // Top border\n    finalWalls.add(`${gridSize - 1}-${i}`); // Bottom border\n    finalWalls.add(`${i}-0`); // Left border\n    finalWalls.add(`${i}-${gridSize - 1}`); // Right border\n  }\n  \n  return finalWalls;\n}\n\n/**\n * Sleep function for animation delays\n */\nfunction sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n/**\n * Generate maze steps for step-by-step visualization\n * Returns an array of steps that can be played back\n */\nexport const getPrimsMazeSteps = (gridSize) => {\n  const steps = [];\n  const walls = new Set();\n  const visited = new Set();\n  const frontierWalls = new PriorityQueue();\n  \n  // Initialize all cells as walls\n  for (let row = 0; row < gridSize; row++) {\n    for (let col = 0; col < gridSize; col++) {\n      walls.add(`${row}-${col}`);\n    }\n  }\n\n  // Start from center or random position\n  const startRow = Math.floor(gridSize / 2);\n  const startCol = Math.floor(gridSize / 2);\n  const startCell = `${startRow}-${startCol}`;\n  \n  walls.delete(startCell);\n  visited.add(startCell);\n  addFrontierWalls(startRow, startCol, gridSize, walls, visited, frontierWalls);\n  \n  steps.push({\n    walls: new Set(walls),\n    visited: new Set(visited),\n    action: 'start',\n    cell: startCell\n  });\n\n  // Generate steps\n  while (!frontierWalls.isEmpty()) {\n    const currentWall = frontierWalls.dequeue();\n    if (!currentWall) break;\n    \n    const [wallRow, wallCol] = currentWall.split('-').map(Number);\n    const wallKey = `${wallRow}-${wallCol}`;\n    \n    if (!walls.has(wallKey)) continue;\n    \n    const adjacentPassages = getAdjacentPassages(wallRow, wallCol, gridSize, walls);\n    \n    if (adjacentPassages.length > 0) {\n      walls.delete(wallKey);\n      visited.add(wallKey);\n      addFrontierWalls(wallRow, wallCol, gridSize, walls, visited, frontierWalls);\n      \n      steps.push({\n        walls: new Set(walls),\n        visited: new Set(visited),\n        action: 'carve',\n        cell: wallKey\n      });\n    }\n  }\n\n  // Final cleanup step\n  const finalWalls = cleanupMaze(walls, gridSize);\n  steps.push({\n    walls: finalWalls,\n    visited: new Set(visited),\n    action: 'complete',\n    cell: null\n  });\n\n  return steps;\n};\n\nexport default generateMazeWithPrims;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}