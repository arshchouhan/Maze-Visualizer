{"ast":null,"code":"var _jsxFileName = \"E:\\\\maze_analyser\\\\src\\\\components\\\\Matrix.js\";\nimport React from 'react';\nimport { PlayIcon, CheckCircleIcon } from '@heroicons/react/24/solid';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Matrix = ({\n  gridSize = 20,\n  startPos,\n  targetPos,\n  walls,\n  onCellClick,\n  onMouseDown,\n  onMouseEnter,\n  onMouseUp,\n  dragMode,\n  visitedCells = new Set(),\n  pathCells = new Set(),\n  mazeGenerationCells = new Set(),\n  isVisualizing = false\n}) => {\n  // Calculate cell type (empty, wall, start, or target)\n  const getCellType = (row, col) => {\n    if (row === startPos.row && col === startPos.col) return 'start';\n    if (row === targetPos.row && col === targetPos.col) return 'target';\n    if (walls.has(`${row}-${col}`)) return 'wall';\n    return 'empty';\n  };\n\n  // Get appropriate styles based on cell type\n  const getCellStyle = (row, col) => {\n    const type = getCellType(row, col);\n    const cellKey = `${row}-${col}`;\n    let backgroundColor = '#e2e8f0'; // Default light gray\n    let animation = '';\n    if (type === 'start') {\n      backgroundColor = '#10b981'; // Green\n    } else if (type === 'target') {\n      backgroundColor = '#f59e0b'; // Amber\n    } else if (type === 'wall') {\n      backgroundColor = '#4b5563'; // Dark gray\n    } else if (pathCells.has(cellKey)) {\n      backgroundColor = '#3b82f6'; // Blue\n      animation = 'pulse 1s infinite';\n    } else if (mazeGenerationCells.has(cellKey)) {\n      backgroundColor = '#f97316'; // Orange\n      animation = 'pulse 1s infinite';\n    } else if (visitedCells.has(cellKey)) {\n      backgroundColor = '#0d9488'; // Teal\n      // Alternating colors for empty cells (chessboard pattern)\n      const isEven = (row + col) % 2 === 0;\n      className += isEven ? ' bg-[#2C3648]' : ' bg-[#1F2937]';\n    }\n    return className;\n  };\n\n  // Render cell content (icons for start and target)\n  const renderCellContent = (row, col) => {\n    const type = getCellType(row, col);\n    if (type === 'start') {\n      return /*#__PURE__*/_jsxDEV(PlayIcon, {\n        style: {\n          width: '60%',\n          height: '60%',\n          color: 'white'\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 63,\n        columnNumber: 9\n      }, this);\n    } else if (type === 'target') {\n      return /*#__PURE__*/_jsxDEV(CheckCircleIcon, {\n        style: {\n          width: '60%',\n          height: '60%',\n          color: 'white'\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 67,\n        columnNumber: 9\n      }, this);\n    }\n    return null;\n  };\n\n  // Create all cells for the grid\n  const renderCells = () => {\n    const cells = [];\n    for (let row = 0; row < gridSize; row++) {\n      for (let col = 0; col < gridSize; col++) {\n        cells.push(/*#__PURE__*/_jsxDEV(\"div\", {\n          onClick: () => onCellClick(row, col),\n          onMouseDown: () => onMouseDown(row, col),\n          onMouseEnter: () => onMouseEnter(row, col),\n          onMouseUp: onMouseUp,\n          onDragStart: e => e.preventDefault(),\n          style: getCellStyle(row, col),\n          children: renderCellContent(row, col)\n        }, `${row}-${col}`, false, {\n          fileName: _jsxFileName,\n          lineNumber: 81,\n          columnNumber: 11\n        }, this));\n      }\n    }\n    return cells;\n  };\n\n  // Render the matrix - fill the entire container with no padding or gaps\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    style: {\n      width: '100%',\n      height: '100%',\n      display: 'grid',\n      gridTemplateColumns: `repeat(${gridSize}, 1fr)`,\n      gridTemplateRows: `repeat(${gridSize}, 1fr)`,\n      gap: '1px',\n      backgroundColor: '#374151',\n      border: '1px solid #374151'\n    },\n    children: renderCells()\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 101,\n    columnNumber: 5\n  }, this);\n};\n_c = Matrix;\nexport default Matrix;\nvar _c;\n$RefreshReg$(_c, \"Matrix\");","map":{"version":3,"names":["React","PlayIcon","CheckCircleIcon","jsxDEV","_jsxDEV","Matrix","gridSize","startPos","targetPos","walls","onCellClick","onMouseDown","onMouseEnter","onMouseUp","dragMode","visitedCells","Set","pathCells","mazeGenerationCells","isVisualizing","getCellType","row","col","has","getCellStyle","type","cellKey","backgroundColor","animation","isEven","className","renderCellContent","style","width","height","color","fileName","_jsxFileName","lineNumber","columnNumber","renderCells","cells","push","onClick","onDragStart","e","preventDefault","children","display","gridTemplateColumns","gridTemplateRows","gap","border","_c","$RefreshReg$"],"sources":["E:/maze_analyser/src/components/Matrix.js"],"sourcesContent":["import React from 'react';\nimport { PlayIcon, CheckCircleIcon } from '@heroicons/react/24/solid';\n\nconst Matrix = ({\n  gridSize = 20,\n  startPos,\n  targetPos,\n  walls,\n  onCellClick,\n  onMouseDown,\n  onMouseEnter,\n  onMouseUp,\n  dragMode,\n  visitedCells = new Set(),\n  pathCells = new Set(),\n  mazeGenerationCells = new Set(),\n  isVisualizing = false\n}) => {\n  // Calculate cell type (empty, wall, start, or target)\n  const getCellType = (row, col) => {\n    if (row === startPos.row && col === startPos.col) return 'start';\n    if (row === targetPos.row && col === targetPos.col) return 'target';\n    if (walls.has(`${row}-${col}`)) return 'wall';\n    return 'empty';\n  };\n\n  // Get appropriate styles based on cell type\n  const getCellStyle = (row, col) => {\n    const type = getCellType(row, col);\n    const cellKey = `${row}-${col}`;\n    \n    let backgroundColor = '#e2e8f0'; // Default light gray\n    let animation = '';\n    \n    if (type === 'start') {\n      backgroundColor = '#10b981'; // Green\n    } else if (type === 'target') {\n      backgroundColor = '#f59e0b'; // Amber\n    } else if (type === 'wall') {\n      backgroundColor = '#4b5563'; // Dark gray\n    } else if (pathCells.has(cellKey)) {\n      backgroundColor = '#3b82f6'; // Blue\n      animation = 'pulse 1s infinite';\n    } else if (mazeGenerationCells.has(cellKey)) {\n      backgroundColor = '#f97316'; // Orange\n      animation = 'pulse 1s infinite';\n    } else if (visitedCells.has(cellKey)) {\n      backgroundColor = '#0d9488'; // Teal\n      // Alternating colors for empty cells (chessboard pattern)\n      const isEven = (row + col) % 2 === 0;\n      className += isEven ? ' bg-[#2C3648]' : ' bg-[#1F2937]';\n    }\n\n    return className;\n  };\n\n  // Render cell content (icons for start and target)\n  const renderCellContent = (row, col) => {\n    const type = getCellType(row, col);\n    \n    if (type === 'start') {\n      return (\n        <PlayIcon style={{ width: '60%', height: '60%', color: 'white' }} />\n      );\n    } else if (type === 'target') {\n      return (\n        <CheckCircleIcon style={{ width: '60%', height: '60%', color: 'white' }} />\n      );\n    }\n    \n    return null;\n  };\n\n  // Create all cells for the grid\n  const renderCells = () => {\n    const cells = [];\n    \n    for (let row = 0; row < gridSize; row++) {\n      for (let col = 0; col < gridSize; col++) {\n        cells.push(\n          <div\n            key={`${row}-${col}`}\n            onClick={() => onCellClick(row, col)}\n            onMouseDown={() => onMouseDown(row, col)}\n            onMouseEnter={() => onMouseEnter(row, col)}\n            onMouseUp={onMouseUp}\n            onDragStart={(e) => e.preventDefault()}\n            style={getCellStyle(row, col)}\n          >\n            {renderCellContent(row, col)}\n          </div>\n        );\n      }\n    }\n    \n    return cells;\n  };\n\n  // Render the matrix - fill the entire container with no padding or gaps\n  return (\n    <div style={{\n      width: '100%',\n      height: '100%',\n      display: 'grid',\n      gridTemplateColumns: `repeat(${gridSize}, 1fr)`,\n      gridTemplateRows: `repeat(${gridSize}, 1fr)`,\n      gap: '1px',\n      backgroundColor: '#374151',\n      border: '1px solid #374151'\n    }}>\n      {renderCells()}\n    </div>\n  );\n};\n\nexport default Matrix;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}