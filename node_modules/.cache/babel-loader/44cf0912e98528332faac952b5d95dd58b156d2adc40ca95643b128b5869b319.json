{"ast":null,"code":"/**\n * Prim's Algorithm for Maze Generation\n * \n * This algorithm generates a maze by starting with a grid full of walls and \n * carving out passages using Prim's minimum spanning tree algorithm.\n * \n * Data Structures Used:\n * - Set: For tracking visited cells and walls\n * - Array: For frontier walls (acts as a priority queue)\n * - Map: For parent tracking during generation\n */\n\n/**\n * Priority Queue implementation using array for Prim's algorithm\n */\nclass PriorityQueue {\n  constructor() {\n    this.items = [];\n  }\n  enqueue(element, priority = Math.random()) {\n    const queueElement = {\n      element,\n      priority\n    };\n    let added = false;\n    for (let i = 0; i < this.items.length; i++) {\n      if (queueElement.priority < this.items[i].priority) {\n        this.items.splice(i, 0, queueElement);\n        added = true;\n        break;\n      }\n    }\n    if (!added) {\n      this.items.push(queueElement);\n    }\n  }\n  dequeue() {\n    var _this$items$shift;\n    return (_this$items$shift = this.items.shift()) === null || _this$items$shift === void 0 ? void 0 : _this$items$shift.element;\n  }\n  isEmpty() {\n    return this.items.length === 0;\n  }\n  size() {\n    return this.items.length;\n  }\n}\n\n/**\n * Generates a maze using Prim's algorithm with animation\n * @param {number} gridSize - The size of the grid (gridSize x gridSize)\n * @param {Function} updateWalls - Callback to update UI with current walls\n * @param {Function} updateMazeGeneration - Callback to update UI with maze generation cells\n * @param {number} animationSpeed - Speed of animation in milliseconds\n * @param {Object} startPos - Starting position {row, col}\n * @param {Object} targetPos - Target position {row, col}\n * @returns {Object} - Results including final walls set and generation stats\n */\nexport const generateMazeWithPrims = async (gridSize, updateWalls, updateMazeGeneration, animationSpeed = 100, startPos = {\n  row: 1,\n  col: 1\n}, targetPos = {\n  row: gridSize - 2,\n  col: gridSize - 2\n}) => {\n  // Initialize: Start with all cells as walls except borders\n  const walls = new Set();\n  const passages = new Set();\n  const frontierCells = [];\n  const mazeGenerationCells = new Set();\n\n  // Create border walls and fill interior with walls\n  for (let row = 0; row < gridSize; row++) {\n    for (let col = 0; col < gridSize; col++) {\n      // Always make borders walls\n      if (row === 0 || row === gridSize - 1 || col === 0 || col === gridSize - 1) {\n        walls.add(`${row}-${col}`);\n      } else {\n        // Interior starts as walls too\n        walls.add(`${row}-${col}`);\n      }\n    }\n  }\n\n  // Start from top-left corner (avoiding border)\n  const startRow = 1;\n  const startCol = 1;\n  const startCell = `${startRow}-${startCol}`;\n\n  // Make starting cell a passage\n  walls.delete(startCell);\n  passages.add(startCell);\n\n  // Add neighbors of starting cell to frontier\n  addNeighborsToFrontier(startRow, startCol, gridSize, walls, passages, frontierCells);\n  let generationSteps = 0;\n\n  // Update initial state\n  updateWalls(new Set(walls));\n  updateMazeGeneration(new Set([startCell]));\n  await sleep(animationSpeed);\n\n  // Main Prim's algorithm loop\n  while (frontierCells.length > 0) {\n    // Pick a random frontier cell\n    const randomIndex = Math.floor(Math.random() * frontierCells.length);\n    const [currentRow, currentCol] = frontierCells.splice(randomIndex, 1)[0];\n    const currentCell = `${currentRow}-${currentCol}`;\n\n    // Skip if this cell is already a passage\n    if (passages.has(currentCell)) continue;\n\n    // Find adjacent passage cells\n    const adjacentPassages = getAdjacentPassageCells(currentRow, currentCol, gridSize, passages);\n    if (adjacentPassages.length > 0) {\n      // Make this cell a passage\n      walls.delete(currentCell);\n      passages.add(currentCell);\n      mazeGenerationCells.add(currentCell);\n\n      // Connect to one of the adjacent passages by carving a path\n      const connectTo = adjacentPassages[Math.floor(Math.random() * adjacentPassages.length)];\n      const [connectRow, connectCol] = connectTo.split('-').map(Number);\n\n      // Carve the connecting wall if needed\n      const midRow = Math.floor((currentRow + connectRow) / 2);\n      const midCol = Math.floor((currentCol + connectCol) / 2);\n      const midCell = `${midRow}-${midCol}`;\n      if (walls.has(midCell)) {\n        walls.delete(midCell);\n        passages.add(midCell);\n        mazeGenerationCells.add(midCell);\n      }\n\n      // Add new frontier cells\n      addNeighborsToFrontier(currentRow, currentCol, gridSize, walls, passages, frontierCells);\n      generationSteps++;\n\n      // Update UI with animation\n      updateWalls(new Set(walls));\n      updateMazeGeneration(new Set(mazeGenerationCells));\n      await sleep(animationSpeed);\n    }\n  }\n\n  // Clear maze generation cells after a delay\n  setTimeout(() => {\n    updateMazeGeneration(new Set());\n  }, 1500);\n  return {\n    walls: new Set(walls),\n    generationSteps,\n    visitedCells: passages.size\n  };\n};\n\n/**\n * Add neighboring cells to the frontier list\n */\nfunction addNeighborsToFrontier(row, col, gridSize, walls, passages, frontierCells) {\n  const directions = [[-2, 0], [2, 0], [0, -2], [0, 2] // up, down, left, right (2 steps for maze structure)\n  ];\n  directions.forEach(([dRow, dCol]) => {\n    const newRow = row + dRow;\n    const newCol = col + dCol;\n\n    // Check bounds and if it's a wall that could become a passage\n    if (newRow > 0 && newRow < gridSize - 1 && newCol > 0 && newCol < gridSize - 1 && walls.has(`${newRow}-${newCol}`) && !passages.has(`${newRow}-${newCol}`)) {\n      // Check if this cell is not already in frontier\n      const alreadyInFrontier = frontierCells.some(([r, c]) => r === newRow && c === newCol);\n      if (!alreadyInFrontier) {\n        frontierCells.push([newRow, newCol]);\n      }\n    }\n  });\n}\n\n/**\n * Get adjacent passage cells (cells that are already passages)\n */\nfunction getAdjacentPassageCells(row, col, gridSize, passages) {\n  const directions = [[-2, 0], [2, 0], [0, -2], [0, 2] // up, down, left, right (2 steps for maze structure)\n  ];\n  const adjacentPassages = [];\n  directions.forEach(([dRow, dCol]) => {\n    const newRow = row + dRow;\n    const newCol = col + dCol;\n    const cellKey = `${newRow}-${newCol}`;\n\n    // Check bounds and if it's a passage\n    if (newRow >= 0 && newRow < gridSize && newCol >= 0 && newCol < gridSize && passages.has(cellKey)) {\n      adjacentPassages.push(cellKey);\n    }\n  });\n  return adjacentPassages;\n}\n\n/**\n * Clean up the maze to ensure proper structure\n */\nfunction cleanupMaze(walls, gridSize) {\n  const finalWalls = new Set(walls);\n\n  // Ensure border walls\n  for (let i = 0; i < gridSize; i++) {\n    finalWalls.add(`0-${i}`); // Top border\n    finalWalls.add(`${gridSize - 1}-${i}`); // Bottom border\n    finalWalls.add(`${i}-0`); // Left border\n    finalWalls.add(`${i}-${gridSize - 1}`); // Right border\n  }\n  return finalWalls;\n}\n\n/**\n * Sleep function for animation delays\n */\nfunction sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n/**\n * Generate maze steps for step-by-step visualization\n * Returns an array of steps that can be played back\n * This is a simplified version for potential future use\n */\nexport const getPrimsMazeSteps = gridSize => {\n  const steps = [];\n  const walls = new Set();\n  const passages = new Set();\n  const frontierCells = [];\n\n  // Initialize: Start with all cells as walls\n  for (let row = 0; row < gridSize; row++) {\n    for (let col = 0; col < gridSize; col++) {\n      walls.add(`${row}-${col}`);\n    }\n  }\n\n  // Pick a random starting cell\n  const startRow = 2 + Math.floor(Math.random() * (gridSize - 4));\n  const startCol = 2 + Math.floor(Math.random() * (gridSize - 4));\n  const startCell = `${startRow}-${startCol}`;\n\n  // Make starting cell a passage\n  walls.delete(startCell);\n  passages.add(startCell);\n\n  // Add neighbors to frontier\n  addNeighborsToFrontier(startRow, startCol, gridSize, walls, passages, frontierCells);\n  steps.push({\n    walls: new Set(walls),\n    passages: new Set(passages),\n    action: 'start',\n    cell: startCell\n  });\n\n  // Generate steps\n  while (frontierCells.length > 0) {\n    const randomIndex = Math.floor(Math.random() * frontierCells.length);\n    const [currentRow, currentCol] = frontierCells.splice(randomIndex, 1)[0];\n    const currentCell = `${currentRow}-${currentCol}`;\n    if (passages.has(currentCell)) continue;\n    const adjacentPassages = getAdjacentPassageCells(currentRow, currentCol, gridSize, passages);\n    if (adjacentPassages.length > 0) {\n      walls.delete(currentCell);\n      passages.add(currentCell);\n\n      // Connect to adjacent passage\n      const connectTo = adjacentPassages[Math.floor(Math.random() * adjacentPassages.length)];\n      const [connectRow, connectCol] = connectTo.split('-').map(Number);\n      const midRow = Math.floor((currentRow + connectRow) / 2);\n      const midCol = Math.floor((currentCol + connectCol) / 2);\n      const midCell = `${midRow}-${midCol}`;\n      if (walls.has(midCell)) {\n        walls.delete(midCell);\n        passages.add(midCell);\n      }\n      addNeighborsToFrontier(currentRow, currentCol, gridSize, walls, passages, frontierCells);\n      steps.push({\n        walls: new Set(walls),\n        passages: new Set(passages),\n        action: 'carve',\n        cell: currentCell\n      });\n    }\n  }\n  steps.push({\n    walls: new Set(walls),\n    passages: new Set(passages),\n    action: 'complete',\n    cell: null\n  });\n  return steps;\n};\nexport default generateMazeWithPrims;","map":{"version":3,"names":["PriorityQueue","constructor","items","enqueue","element","priority","Math","random","queueElement","added","i","length","splice","push","dequeue","_this$items$shift","shift","isEmpty","size","generateMazeWithPrims","gridSize","updateWalls","updateMazeGeneration","animationSpeed","startPos","row","col","targetPos","walls","Set","passages","frontierCells","mazeGenerationCells","add","startRow","startCol","startCell","delete","addNeighborsToFrontier","generationSteps","sleep","randomIndex","floor","currentRow","currentCol","currentCell","has","adjacentPassages","getAdjacentPassageCells","connectTo","connectRow","connectCol","split","map","Number","midRow","midCol","midCell","setTimeout","visitedCells","directions","forEach","dRow","dCol","newRow","newCol","alreadyInFrontier","some","r","c","cellKey","cleanupMaze","finalWalls","ms","Promise","resolve","getPrimsMazeSteps","steps","action","cell"],"sources":["E:/maze_analyser/src/algorithms/primsAlgorithm.js"],"sourcesContent":["/**\n * Prim's Algorithm for Maze Generation\n * \n * This algorithm generates a maze by starting with a grid full of walls and \n * carving out passages using Prim's minimum spanning tree algorithm.\n * \n * Data Structures Used:\n * - Set: For tracking visited cells and walls\n * - Array: For frontier walls (acts as a priority queue)\n * - Map: For parent tracking during generation\n */\n\n/**\n * Priority Queue implementation using array for Prim's algorithm\n */\nclass PriorityQueue {\n  constructor() {\n    this.items = [];\n  }\n\n  enqueue(element, priority = Math.random()) {\n    const queueElement = { element, priority };\n    let added = false;\n\n    for (let i = 0; i < this.items.length; i++) {\n      if (queueElement.priority < this.items[i].priority) {\n        this.items.splice(i, 0, queueElement);\n        added = true;\n        break;\n      }\n    }\n\n    if (!added) {\n      this.items.push(queueElement);\n    }\n  }\n\n  dequeue() {\n    return this.items.shift()?.element;\n  }\n\n  isEmpty() {\n    return this.items.length === 0;\n  }\n\n  size() {\n    return this.items.length;\n  }\n}\n\n/**\n * Generates a maze using Prim's algorithm with animation\n * @param {number} gridSize - The size of the grid (gridSize x gridSize)\n * @param {Function} updateWalls - Callback to update UI with current walls\n * @param {Function} updateMazeGeneration - Callback to update UI with maze generation cells\n * @param {number} animationSpeed - Speed of animation in milliseconds\n * @param {Object} startPos - Starting position {row, col}\n * @param {Object} targetPos - Target position {row, col}\n * @returns {Object} - Results including final walls set and generation stats\n */\nexport const generateMazeWithPrims = async (\n  gridSize,\n  updateWalls,\n  updateMazeGeneration,\n  animationSpeed = 100,\n  startPos = { row: 1, col: 1 },\n  targetPos = { row: gridSize - 2, col: gridSize - 2 }\n) => {\n  // Initialize: Start with all cells as walls except borders\n  const walls = new Set();\n  const passages = new Set();\n  const frontierCells = [];\n  const mazeGenerationCells = new Set();\n  \n  // Create border walls and fill interior with walls\n  for (let row = 0; row < gridSize; row++) {\n    for (let col = 0; col < gridSize; col++) {\n      // Always make borders walls\n      if (row === 0 || row === gridSize - 1 || col === 0 || col === gridSize - 1) {\n        walls.add(`${row}-${col}`);\n      } else {\n        // Interior starts as walls too\n        walls.add(`${row}-${col}`);\n      }\n    }\n  }\n\n  // Start from top-left corner (avoiding border)\n  const startRow = 1;\n  const startCol = 1;\n  const startCell = `${startRow}-${startCol}`;\n  \n  // Make starting cell a passage\n  walls.delete(startCell);\n  passages.add(startCell);\n  \n  // Add neighbors of starting cell to frontier\n  addNeighborsToFrontier(startRow, startCol, gridSize, walls, passages, frontierCells);\n  \n  let generationSteps = 0;\n  \n  // Update initial state\n  updateWalls(new Set(walls));\n  updateMazeGeneration(new Set([startCell]));\n  await sleep(animationSpeed);\n\n  // Main Prim's algorithm loop\n  while (frontierCells.length > 0) {\n    // Pick a random frontier cell\n    const randomIndex = Math.floor(Math.random() * frontierCells.length);\n    const [currentRow, currentCol] = frontierCells.splice(randomIndex, 1)[0];\n    const currentCell = `${currentRow}-${currentCol}`;\n    \n    // Skip if this cell is already a passage\n    if (passages.has(currentCell)) continue;\n    \n    // Find adjacent passage cells\n    const adjacentPassages = getAdjacentPassageCells(currentRow, currentCol, gridSize, passages);\n    \n    if (adjacentPassages.length > 0) {\n      // Make this cell a passage\n      walls.delete(currentCell);\n      passages.add(currentCell);\n      mazeGenerationCells.add(currentCell);\n      \n      // Connect to one of the adjacent passages by carving a path\n      const connectTo = adjacentPassages[Math.floor(Math.random() * adjacentPassages.length)];\n      const [connectRow, connectCol] = connectTo.split('-').map(Number);\n      \n      // Carve the connecting wall if needed\n      const midRow = Math.floor((currentRow + connectRow) / 2);\n      const midCol = Math.floor((currentCol + connectCol) / 2);\n      const midCell = `${midRow}-${midCol}`;\n      \n      if (walls.has(midCell)) {\n        walls.delete(midCell);\n        passages.add(midCell);\n        mazeGenerationCells.add(midCell);\n      }\n      \n      // Add new frontier cells\n      addNeighborsToFrontier(currentRow, currentCol, gridSize, walls, passages, frontierCells);\n      \n      generationSteps++;\n      \n      // Update UI with animation\n      updateWalls(new Set(walls));\n      updateMazeGeneration(new Set(mazeGenerationCells));\n      await sleep(animationSpeed);\n    }\n  }\n\n  // Clear maze generation cells after a delay\n  setTimeout(() => {\n    updateMazeGeneration(new Set());\n  }, 1500);\n  \n  return {\n    walls: new Set(walls),\n    generationSteps,\n    visitedCells: passages.size\n  };\n};\n\n/**\n * Add neighboring cells to the frontier list\n */\nfunction addNeighborsToFrontier(row, col, gridSize, walls, passages, frontierCells) {\n  const directions = [\n    [-2, 0], [2, 0], [0, -2], [0, 2] // up, down, left, right (2 steps for maze structure)\n  ];\n  \n  directions.forEach(([dRow, dCol]) => {\n    const newRow = row + dRow;\n    const newCol = col + dCol;\n    \n    // Check bounds and if it's a wall that could become a passage\n    if (\n      newRow > 0 && newRow < gridSize - 1 &&\n      newCol > 0 && newCol < gridSize - 1 &&\n      walls.has(`${newRow}-${newCol}`) &&\n      !passages.has(`${newRow}-${newCol}`)\n    ) {\n      // Check if this cell is not already in frontier\n      const alreadyInFrontier = frontierCells.some(([r, c]) => r === newRow && c === newCol);\n      if (!alreadyInFrontier) {\n        frontierCells.push([newRow, newCol]);\n      }\n    }\n  });\n}\n\n/**\n * Get adjacent passage cells (cells that are already passages)\n */\nfunction getAdjacentPassageCells(row, col, gridSize, passages) {\n  const directions = [\n    [-2, 0], [2, 0], [0, -2], [0, 2] // up, down, left, right (2 steps for maze structure)\n  ];\n  const adjacentPassages = [];\n  \n  directions.forEach(([dRow, dCol]) => {\n    const newRow = row + dRow;\n    const newCol = col + dCol;\n    const cellKey = `${newRow}-${newCol}`;\n    \n    // Check bounds and if it's a passage\n    if (\n      newRow >= 0 && newRow < gridSize &&\n      newCol >= 0 && newCol < gridSize &&\n      passages.has(cellKey)\n    ) {\n      adjacentPassages.push(cellKey);\n    }\n  });\n  \n  return adjacentPassages;\n}\n\n/**\n * Clean up the maze to ensure proper structure\n */\nfunction cleanupMaze(walls, gridSize) {\n  const finalWalls = new Set(walls);\n  \n  // Ensure border walls\n  for (let i = 0; i < gridSize; i++) {\n    finalWalls.add(`0-${i}`); // Top border\n    finalWalls.add(`${gridSize - 1}-${i}`); // Bottom border\n    finalWalls.add(`${i}-0`); // Left border\n    finalWalls.add(`${i}-${gridSize - 1}`); // Right border\n  }\n  \n  return finalWalls;\n}\n\n/**\n * Sleep function for animation delays\n */\nfunction sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n/**\n * Generate maze steps for step-by-step visualization\n * Returns an array of steps that can be played back\n * This is a simplified version for potential future use\n */\nexport const getPrimsMazeSteps = (gridSize) => {\n  const steps = [];\n  const walls = new Set();\n  const passages = new Set();\n  const frontierCells = [];\n  \n  // Initialize: Start with all cells as walls\n  for (let row = 0; row < gridSize; row++) {\n    for (let col = 0; col < gridSize; col++) {\n      walls.add(`${row}-${col}`);\n    }\n  }\n\n  // Pick a random starting cell\n  const startRow = 2 + Math.floor(Math.random() * (gridSize - 4));\n  const startCol = 2 + Math.floor(Math.random() * (gridSize - 4));\n  const startCell = `${startRow}-${startCol}`;\n  \n  // Make starting cell a passage\n  walls.delete(startCell);\n  passages.add(startCell);\n  \n  // Add neighbors to frontier\n  addNeighborsToFrontier(startRow, startCol, gridSize, walls, passages, frontierCells);\n  \n  steps.push({\n    walls: new Set(walls),\n    passages: new Set(passages),\n    action: 'start',\n    cell: startCell\n  });\n\n  // Generate steps\n  while (frontierCells.length > 0) {\n    const randomIndex = Math.floor(Math.random() * frontierCells.length);\n    const [currentRow, currentCol] = frontierCells.splice(randomIndex, 1)[0];\n    const currentCell = `${currentRow}-${currentCol}`;\n    \n    if (passages.has(currentCell)) continue;\n    \n    const adjacentPassages = getAdjacentPassageCells(currentRow, currentCol, gridSize, passages);\n    \n    if (adjacentPassages.length > 0) {\n      walls.delete(currentCell);\n      passages.add(currentCell);\n      \n      // Connect to adjacent passage\n      const connectTo = adjacentPassages[Math.floor(Math.random() * adjacentPassages.length)];\n      const [connectRow, connectCol] = connectTo.split('-').map(Number);\n      \n      const midRow = Math.floor((currentRow + connectRow) / 2);\n      const midCol = Math.floor((currentCol + connectCol) / 2);\n      const midCell = `${midRow}-${midCol}`;\n      \n      if (walls.has(midCell)) {\n        walls.delete(midCell);\n        passages.add(midCell);\n      }\n      \n      addNeighborsToFrontier(currentRow, currentCol, gridSize, walls, passages, frontierCells);\n      \n      steps.push({\n        walls: new Set(walls),\n        passages: new Set(passages),\n        action: 'carve',\n        cell: currentCell\n      });\n    }\n  }\n\n  steps.push({\n    walls: new Set(walls),\n    passages: new Set(passages),\n    action: 'complete',\n    cell: null\n  });\n\n  return steps;\n};\n\nexport default generateMazeWithPrims;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}