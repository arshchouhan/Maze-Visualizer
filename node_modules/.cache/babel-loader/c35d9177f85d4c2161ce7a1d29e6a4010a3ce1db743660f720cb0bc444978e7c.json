{"ast":null,"code":"/**\n * Algorithm Visualization Controller\n * \n * This file handles the animation and visualization of pathfinding algorithms\n */\nimport { breadthFirstSearch } from './breadthFirstSearch';\n\n// Animation speed in milliseconds\nconst ANIMATION_SPEED_MS = 10;\n\n/**\n * Animates the algorithm visualization process\n * \n * @param {string} algorithm - The name of the algorithm to use\n * @param {Object} grid - The grid data\n * @param {Object} startPos - The starting position\n * @param {Object} targetPos - The target position\n * @param {Set} walls - Set of wall positions\n * @param {number} rows - Total number of rows\n * @param {number} cols - Total number of columns\n * @param {Function} setVisitedNodes - State setter for visited nodes\n * @param {Function} setPathNodes - State setter for path nodes\n * @param {Function} setIsRunning - State setter for algorithm running status\n * @param {Function} setMessage - State setter for algorithm result message\n * @returns {Promise} - Promise that resolves when animation is complete\n */\nexport const animateAlgorithm = async (algorithm, grid, startPos, targetPos, walls, rows, cols, setVisitedNodes, setPathNodes, setIsRunning, setMessage) => {\n  // Mark the algorithm as running\n  setIsRunning(true);\n\n  // Reset visualization state\n  setVisitedNodes([]);\n  setPathNodes([]);\n\n  // Choose the appropriate algorithm function\n  let result;\n  switch (algorithm) {\n    case 'breadth-first':\n      result = breadthFirstSearch(grid, startPos, targetPos, walls, rows, cols);\n      break;\n    case 'depth-first':\n      // Will be implemented later\n      setMessage(\"Depth-first search not implemented yet\");\n      setIsRunning(false);\n      return;\n    case 'astar':\n      // Will be implemented later\n      setMessage(\"A* algorithm not implemented yet\");\n      setIsRunning(false);\n      return;\n    case 'dijkstra':\n      // Will be implemented later\n      setMessage(\"Dijkstra's algorithm not implemented yet\");\n      setIsRunning(false);\n      return;\n    default:\n      setMessage(\"Please select a valid algorithm\");\n      setIsRunning(false);\n      return;\n  }\n\n  // If no path found, show message and visited nodes\n  if (!result.success) {\n    await animateVisitedNodes(result.visited, setVisitedNodes);\n    setMessage(result.message);\n    setIsRunning(false);\n    return;\n  }\n\n  // Animate the visited nodes\n  await animateVisitedNodes(result.visited, setVisitedNodes);\n\n  // Then animate the final path\n  await animatePath(result.path, setPathNodes);\n\n  // Display success message\n  setMessage(result.message);\n\n  // Mark the algorithm as completed\n  setIsRunning(false);\n};\n\n/**\n * Animates the nodes that were visited during algorithm execution\n * \n * @param {Array} visitedNodes - Array of visited node positions\n * @param {Function} setVisitedNodes - State setter function\n * @returns {Promise} - Promise that resolves when animation is complete\n */\nconst animateVisitedNodes = async (visitedNodes, setVisitedNodes) => {\n  return new Promise(resolve => {\n    const animations = [];\n\n    // Skip the start node in the animation (first node in visitedNodes)\n    for (let i = 1; i < visitedNodes.length; i++) {\n      animations.push(i);\n    }\n\n    // Run the animation\n    animations.forEach((index, i) => {\n      setTimeout(() => {\n        setVisitedNodes(prev => {\n          const newVisitedNodes = [...prev];\n          newVisitedNodes.push(visitedNodes[index]);\n          return newVisitedNodes;\n        });\n\n        // Resolve the promise when the last animation is done\n        if (i === animations.length - 1) {\n          resolve();\n        }\n      }, i * ANIMATION_SPEED_MS);\n    });\n\n    // If no animations to run, resolve immediately\n    if (animations.length === 0) {\n      resolve();\n    }\n  });\n};\n\n/**\n * Animates the final path found by the algorithm\n * \n * @param {Array} path - Array of path node positions\n * @param {Function} setPathNodes - State setter function\n * @returns {Promise} - Promise that resolves when animation is complete\n */\nconst animatePath = async (path, setPathNodes) => {\n  return new Promise(resolve => {\n    const animations = [];\n\n    // Skip the start and end nodes in the path animation\n    for (let i = 1; i < path.length - 1; i++) {\n      animations.push(i);\n    }\n\n    // Run the animation\n    animations.forEach((index, i) => {\n      setTimeout(() => {\n        setPathNodes(prev => {\n          const newPathNodes = [...prev];\n          newPathNodes.push(path[index]);\n          return newPathNodes;\n        });\n\n        // Resolve the promise when the last animation is done\n        if (i === animations.length - 1) {\n          resolve();\n        }\n      }, i * ANIMATION_SPEED_MS * 3); // Path animation is slower for emphasis\n    });\n\n    // If no animations to run, resolve immediately\n    if (animations.length === 0) {\n      resolve();\n    }\n  });\n};\n\n/**\n * Returns stats about the algorithm execution\n * \n * @param {Array} visitedNodes - Array of visited nodes\n * @param {Array} pathNodes - Array of path nodes\n * @returns {Object} - Object containing algorithm stats\n */\nexport const getAlgorithmStats = (visitedNodes, pathNodes) => {\n  return {\n    nodesVisited: visitedNodes.length,\n    pathLength: pathNodes.length > 0 ? pathNodes.length + 1 : 0,\n    // +1 for start node\n    executionTime: visitedNodes.length * ANIMATION_SPEED_MS / 1000 // Approximate time in seconds\n  };\n};","map":{"version":3,"names":["breadthFirstSearch","ANIMATION_SPEED_MS","animateAlgorithm","algorithm","grid","startPos","targetPos","walls","rows","cols","setVisitedNodes","setPathNodes","setIsRunning","setMessage","result","success","animateVisitedNodes","visited","message","animatePath","path","visitedNodes","Promise","resolve","animations","i","length","push","forEach","index","setTimeout","prev","newVisitedNodes","newPathNodes","getAlgorithmStats","pathNodes","nodesVisited","pathLength","executionTime"],"sources":["E:/maze_analyser/src/algorithms/visualizer.js"],"sourcesContent":["/**\n * Algorithm Visualization Controller\n * \n * This file handles the animation and visualization of pathfinding algorithms\n */\nimport { breadthFirstSearch } from './breadthFirstSearch';\n\n// Animation speed in milliseconds\nconst ANIMATION_SPEED_MS = 10;\n\n/**\n * Animates the algorithm visualization process\n * \n * @param {string} algorithm - The name of the algorithm to use\n * @param {Object} grid - The grid data\n * @param {Object} startPos - The starting position\n * @param {Object} targetPos - The target position\n * @param {Set} walls - Set of wall positions\n * @param {number} rows - Total number of rows\n * @param {number} cols - Total number of columns\n * @param {Function} setVisitedNodes - State setter for visited nodes\n * @param {Function} setPathNodes - State setter for path nodes\n * @param {Function} setIsRunning - State setter for algorithm running status\n * @param {Function} setMessage - State setter for algorithm result message\n * @returns {Promise} - Promise that resolves when animation is complete\n */\nexport const animateAlgorithm = async (\n  algorithm,\n  grid,\n  startPos,\n  targetPos,\n  walls,\n  rows,\n  cols,\n  setVisitedNodes,\n  setPathNodes,\n  setIsRunning,\n  setMessage\n) => {\n  // Mark the algorithm as running\n  setIsRunning(true);\n  \n  // Reset visualization state\n  setVisitedNodes([]);\n  setPathNodes([]);\n  \n  // Choose the appropriate algorithm function\n  let result;\n  switch(algorithm) {\n    case 'breadth-first':\n      result = breadthFirstSearch(grid, startPos, targetPos, walls, rows, cols);\n      break;\n    case 'depth-first':\n      // Will be implemented later\n      setMessage(\"Depth-first search not implemented yet\");\n      setIsRunning(false);\n      return;\n    case 'astar':\n      // Will be implemented later\n      setMessage(\"A* algorithm not implemented yet\");\n      setIsRunning(false);\n      return;\n    case 'dijkstra':\n      // Will be implemented later\n      setMessage(\"Dijkstra's algorithm not implemented yet\");\n      setIsRunning(false);\n      return;\n    default:\n      setMessage(\"Please select a valid algorithm\");\n      setIsRunning(false);\n      return;\n  }\n  \n  // If no path found, show message and visited nodes\n  if (!result.success) {\n    await animateVisitedNodes(result.visited, setVisitedNodes);\n    setMessage(result.message);\n    setIsRunning(false);\n    return;\n  }\n  \n  // Animate the visited nodes\n  await animateVisitedNodes(result.visited, setVisitedNodes);\n  \n  // Then animate the final path\n  await animatePath(result.path, setPathNodes);\n  \n  // Display success message\n  setMessage(result.message);\n  \n  // Mark the algorithm as completed\n  setIsRunning(false);\n};\n\n/**\n * Animates the nodes that were visited during algorithm execution\n * \n * @param {Array} visitedNodes - Array of visited node positions\n * @param {Function} setVisitedNodes - State setter function\n * @returns {Promise} - Promise that resolves when animation is complete\n */\nconst animateVisitedNodes = async (visitedNodes, setVisitedNodes) => {\n  return new Promise((resolve) => {\n    const animations = [];\n    \n    // Skip the start node in the animation (first node in visitedNodes)\n    for (let i = 1; i < visitedNodes.length; i++) {\n      animations.push(i);\n    }\n    \n    // Run the animation\n    animations.forEach((index, i) => {\n      setTimeout(() => {\n        setVisitedNodes(prev => {\n          const newVisitedNodes = [...prev];\n          newVisitedNodes.push(visitedNodes[index]);\n          return newVisitedNodes;\n        });\n        \n        // Resolve the promise when the last animation is done\n        if (i === animations.length - 1) {\n          resolve();\n        }\n      }, i * ANIMATION_SPEED_MS);\n    });\n    \n    // If no animations to run, resolve immediately\n    if (animations.length === 0) {\n      resolve();\n    }\n  });\n};\n\n/**\n * Animates the final path found by the algorithm\n * \n * @param {Array} path - Array of path node positions\n * @param {Function} setPathNodes - State setter function\n * @returns {Promise} - Promise that resolves when animation is complete\n */\nconst animatePath = async (path, setPathNodes) => {\n  return new Promise((resolve) => {\n    const animations = [];\n    \n    // Skip the start and end nodes in the path animation\n    for (let i = 1; i < path.length - 1; i++) {\n      animations.push(i);\n    }\n    \n    // Run the animation\n    animations.forEach((index, i) => {\n      setTimeout(() => {\n        setPathNodes(prev => {\n          const newPathNodes = [...prev];\n          newPathNodes.push(path[index]);\n          return newPathNodes;\n        });\n        \n        // Resolve the promise when the last animation is done\n        if (i === animations.length - 1) {\n          resolve();\n        }\n      }, i * ANIMATION_SPEED_MS * 3); // Path animation is slower for emphasis\n    });\n    \n    // If no animations to run, resolve immediately\n    if (animations.length === 0) {\n      resolve();\n    }\n  });\n};\n\n/**\n * Returns stats about the algorithm execution\n * \n * @param {Array} visitedNodes - Array of visited nodes\n * @param {Array} pathNodes - Array of path nodes\n * @returns {Object} - Object containing algorithm stats\n */\nexport const getAlgorithmStats = (visitedNodes, pathNodes) => {\n  return {\n    nodesVisited: visitedNodes.length,\n    pathLength: pathNodes.length > 0 ? pathNodes.length + 1 : 0, // +1 for start node\n    executionTime: visitedNodes.length * ANIMATION_SPEED_MS / 1000, // Approximate time in seconds\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}