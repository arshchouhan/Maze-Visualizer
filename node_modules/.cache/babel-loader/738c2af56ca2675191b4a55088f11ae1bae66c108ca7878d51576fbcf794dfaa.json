{"ast":null,"code":"var _jsxFileName = \"E:\\\\maze_analyser\\\\src\\\\components\\\\Matrix.js\";\nimport React from 'react';\nimport { PlayIcon, CheckCircleIcon } from '@heroicons/react/24/solid';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Matrix = ({\n  gridSize = 20,\n  startPos,\n  targetPos,\n  walls,\n  onCellClick,\n  onMouseDown,\n  onMouseEnter,\n  onMouseUp,\n  dragMode,\n  visitedCells = new Set(),\n  pathCells = new Set(),\n  mazeGenerationCells = new Set(),\n  isVisualizing = false\n}) => {\n  // Calculate cell type (empty, wall, start, or target)\n  const getCellType = (row, col) => {\n    if (row === startPos.row && col === startPos.col) return 'start';\n    if (row === targetPos.row && col === targetPos.col) return 'target';\n    if (walls.has(`${row}-${col}`)) return 'wall';\n    return 'empty';\n  };\n\n  // Check if we're in maze generation mode or if generation just completed\n  const isGenerating = mazeGenerationCells.has('generation_complete') ? false : mazeGenerationCells.size > 0;\n  const generationComplete = mazeGenerationCells.has('generation_complete');\n\n  // Get appropriate styles based on cell type\n  const getCellStyle = (row, col) => {\n    const type = getCellType(row, col);\n    const cellKey = `${row}-${col}`;\n\n    // During maze generation, show the generating path in solid black\n    if (isGenerating && mazeGenerationCells.has(cellKey)) {\n      return {\n        backgroundColor: '#000000',\n        width: '100%',\n        height: '100%',\n        aspectRatio: '1 / 1'\n      };\n    }\n\n    // After generation, paths are gray, everything else is black\n    let backgroundColor = '#e2e8f0'; // Default light gray (for paths during generation)\n    let animation = '';\n\n    // After generation, make paths gray and non-paths black\n    if (generationComplete) {\n      if (type === 'empty' || type === 'path' || mazeGenerationCells.has(cellKey)) {\n        backgroundColor = '#9ca3af'; // Gray for paths\n      } else {\n        backgroundColor = '#000000'; // Black for non-paths\n      }\n    }\n    if (type === 'start') {\n      backgroundColor = '#10b981'; // Green\n    } else if (type === 'target') {\n      backgroundColor = '#f59e0b'; // Amber\n    } else if (type === 'wall') {\n      backgroundColor = '#4b5563'; // Dark gray\n    } else if (pathCells.has(cellKey)) {\n      backgroundColor = '#3b82f6'; // Blue\n      animation = 'pulse 1s infinite';\n    } else if (type === 'wall') {\n      // During generation, use solid dark gray\n      // After generation, walls are black (handled in the generationComplete block above)\n      backgroundColor = generationComplete ? '#000000' : '#4b5563';\n    } else if (visitedCells.has(cellKey)) {\n      backgroundColor = '#0d9488'; // Teal\n    } else {\n      // Alternating colors for empty cells (chessboard pattern)\n      // const isEven = (row + col) % 2 === 0;\n      // backgroundColor = isEven ? '#2C3648' : '#1F2937';\n    }\n    return {\n      backgroundColor,\n      animation,\n      width: '100%',\n      height: '100%',\n      aspectRatio: '1 / 1',\n      display: 'flex',\n      alignItems: 'center',\n      justifyContent: 'center',\n      transition: 'all 0.1s ease',\n      cursor: getCellType(row, col) === 'start' || getCellType(row, col) === 'target' ? 'grab' : dragMode === 'start' || dragMode === 'target' ? 'grabbing' : 'pointer',\n      transform: getCellType(row, col) === 'start' || getCellType(row, col) === 'target' ? 'scale(1.05)' : 'scale(1)'\n    };\n  };\n\n  // Render cell content (icons for start and target)\n  const renderCellContent = (row, col) => {\n    const type = getCellType(row, col);\n    if (type === 'start') {\n      return /*#__PURE__*/_jsxDEV(PlayIcon, {\n        style: {\n          width: '60%',\n          height: '60%',\n          color: 'white'\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 106,\n        columnNumber: 9\n      }, this);\n    } else if (type === 'target') {\n      return /*#__PURE__*/_jsxDEV(CheckCircleIcon, {\n        style: {\n          width: '60%',\n          height: '60%',\n          color: 'white'\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 110,\n        columnNumber: 9\n      }, this);\n    }\n    return null;\n  };\n\n  // Create all cells for the grid\n  const renderCells = () => {\n    const cells = [];\n    for (let row = 0; row < gridSize; row++) {\n      for (let col = 0; col < gridSize; col++) {\n        cells.push(/*#__PURE__*/_jsxDEV(\"div\", {\n          onClick: () => onCellClick(row, col),\n          onMouseDown: () => onMouseDown(row, col),\n          onMouseEnter: () => onMouseEnter(row, col),\n          onMouseUp: onMouseUp,\n          onDragStart: e => e.preventDefault(),\n          style: getCellStyle(row, col),\n          children: renderCellContent(row, col)\n        }, `${row}-${col}`, false, {\n          fileName: _jsxFileName,\n          lineNumber: 124,\n          columnNumber: 11\n        }, this));\n      }\n    }\n    return cells;\n  };\n\n  // Render the matrix - padding is now handled by App.js grid container\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    style: {\n      width: '100%',\n      height: '100%',\n      display: 'grid',\n      gridTemplateColumns: `repeat(${gridSize}, 1fr)`,\n      gridTemplateRows: `repeat(${gridSize}, 1fr)`,\n      gap: '1px',\n      backgroundColor: '#374151',\n      border: '1px solid #374151'\n    },\n    children: renderCells()\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 144,\n    columnNumber: 5\n  }, this);\n};\n_c = Matrix;\nexport default Matrix;\nvar _c;\n$RefreshReg$(_c, \"Matrix\");","map":{"version":3,"names":["React","PlayIcon","CheckCircleIcon","jsxDEV","_jsxDEV","Matrix","gridSize","startPos","targetPos","walls","onCellClick","onMouseDown","onMouseEnter","onMouseUp","dragMode","visitedCells","Set","pathCells","mazeGenerationCells","isVisualizing","getCellType","row","col","has","isGenerating","size","generationComplete","getCellStyle","type","cellKey","backgroundColor","width","height","aspectRatio","animation","display","alignItems","justifyContent","transition","cursor","transform","renderCellContent","style","color","fileName","_jsxFileName","lineNumber","columnNumber","renderCells","cells","push","onClick","onDragStart","e","preventDefault","children","gridTemplateColumns","gridTemplateRows","gap","border","_c","$RefreshReg$"],"sources":["E:/maze_analyser/src/components/Matrix.js"],"sourcesContent":["import React from 'react';\nimport { PlayIcon, CheckCircleIcon } from '@heroicons/react/24/solid';\n\nconst Matrix = ({\n  gridSize = 20,\n  startPos,\n  targetPos,\n  walls,\n  onCellClick,\n  onMouseDown,\n  onMouseEnter,\n  onMouseUp,\n  dragMode,\n  visitedCells = new Set(),\n  pathCells = new Set(),\n  mazeGenerationCells = new Set(),\n  isVisualizing = false\n}) => {\n  // Calculate cell type (empty, wall, start, or target)\n  const getCellType = (row, col) => {\n    if (row === startPos.row && col === startPos.col) return 'start';\n    if (row === targetPos.row && col === targetPos.col) return 'target';\n    if (walls.has(`${row}-${col}`)) return 'wall';\n    return 'empty';\n  };\n\n  // Check if we're in maze generation mode or if generation just completed\n  const isGenerating = mazeGenerationCells.has('generation_complete') ? false : mazeGenerationCells.size > 0;\n  const generationComplete = mazeGenerationCells.has('generation_complete');\n  \n  // Get appropriate styles based on cell type\n  const getCellStyle = (row, col) => {\n    const type = getCellType(row, col);\n    const cellKey = `${row}-${col}`;\n    \n    // During maze generation, show the generating path in solid black\n    if (isGenerating && mazeGenerationCells.has(cellKey)) {\n      return {\n        backgroundColor: '#000000',\n        width: '100%',\n        height: '100%',\n        aspectRatio: '1 / 1',\n      };\n    }\n    \n    // After generation, paths are gray, everything else is black\n    let backgroundColor = '#e2e8f0'; // Default light gray (for paths during generation)\n    let animation = '';\n    \n    // After generation, make paths gray and non-paths black\n    if (generationComplete) {\n      if (type === 'empty' || type === 'path' || mazeGenerationCells.has(cellKey)) {\n        backgroundColor = '#9ca3af'; // Gray for paths\n      } else {\n        backgroundColor = '#000000'; // Black for non-paths\n      }\n    }\n    \n    if (type === 'start') {\n      backgroundColor = '#10b981'; // Green\n    } else if (type === 'target') {\n      backgroundColor = '#f59e0b'; // Amber\n    } else if (type === 'wall') {\n      backgroundColor = '#4b5563'; // Dark gray\n    } else if (pathCells.has(cellKey)) {\n      backgroundColor = '#3b82f6'; // Blue\n      animation = 'pulse 1s infinite';\n    } else if (type === 'wall') {\n      // During generation, use solid dark gray\n      // After generation, walls are black (handled in the generationComplete block above)\n      backgroundColor = generationComplete ? '#000000' : '#4b5563';\n    } else if (visitedCells.has(cellKey)) {\n      backgroundColor = '#0d9488'; // Teal\n    } else {\n      // Alternating colors for empty cells (chessboard pattern)\n      // const isEven = (row + col) % 2 === 0;\n      // backgroundColor = isEven ? '#2C3648' : '#1F2937';\n    }\n\n    return {\n      backgroundColor,\n      animation,\n      width: '100%',\n      height: '100%',\n      aspectRatio: '1 / 1',\n      display: 'flex',\n      alignItems: 'center',\n      justifyContent: 'center',\n      transition: 'all 0.1s ease',\n      cursor: getCellType(row, col) === 'start' || getCellType(row, col) === 'target' \n        ? 'grab' \n        : dragMode === 'start' || dragMode === 'target' ? 'grabbing' \n        : 'pointer',\n      transform: getCellType(row, col) === 'start' || getCellType(row, col) === 'target' \n        ? 'scale(1.05)' \n        : 'scale(1)'\n    };\n  };\n\n  // Render cell content (icons for start and target)\n  const renderCellContent = (row, col) => {\n    const type = getCellType(row, col);\n    \n    if (type === 'start') {\n      return (\n        <PlayIcon style={{ width: '60%', height: '60%', color: 'white' }} />\n      );\n    } else if (type === 'target') {\n      return (\n        <CheckCircleIcon style={{ width: '60%', height: '60%', color: 'white' }} />\n      );\n    }\n    \n    return null;\n  };\n\n  // Create all cells for the grid\n  const renderCells = () => {\n    const cells = [];\n    \n    for (let row = 0; row < gridSize; row++) {\n      for (let col = 0; col < gridSize; col++) {\n        cells.push(\n          <div\n            key={`${row}-${col}`}\n            onClick={() => onCellClick(row, col)}\n            onMouseDown={() => onMouseDown(row, col)}\n            onMouseEnter={() => onMouseEnter(row, col)}\n            onMouseUp={onMouseUp}\n            onDragStart={(e) => e.preventDefault()}\n            style={getCellStyle(row, col)}\n          >\n            {renderCellContent(row, col)}\n          </div>\n        );\n      }\n    }\n    \n    return cells;\n  };\n\n  // Render the matrix - padding is now handled by App.js grid container\n  return (\n    <div style={{\n      width: '100%',\n      height: '100%',\n      display: 'grid',\n      gridTemplateColumns: `repeat(${gridSize}, 1fr)`,\n      gridTemplateRows: `repeat(${gridSize}, 1fr)`,\n      gap: '1px',\n      backgroundColor: '#374151',\n      border: '1px solid #374151'\n    }}>\n      {renderCells()}\n    </div>\n  );\n};\n\nexport default Matrix;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}