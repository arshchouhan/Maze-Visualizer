{"ast":null,"code":"/**\n * Prim's Algorithm for Maze Generation\n * \n * This algorithm generates a maze by starting with a grid full of walls and \n * carving out passages using Prim's minimum spanning tree algorithm.\n * \n * Data Structures Used:\n * - Set: For tracking visited cells and walls\n * - Array: For frontier walls (acts as a priority queue)\n * - Map: For parent tracking during generation\n */\n\n/**\n * Priority Queue implementation using array for Prim's algorithm\n */\nclass PriorityQueue {\n  constructor() {\n    this.items = [];\n  }\n  enqueue(element, priority = Math.random()) {\n    const queueElement = {\n      element,\n      priority\n    };\n    let added = false;\n    for (let i = 0; i < this.items.length; i++) {\n      if (queueElement.priority < this.items[i].priority) {\n        this.items.splice(i, 0, queueElement);\n        added = true;\n        break;\n      }\n    }\n    if (!added) {\n      this.items.push(queueElement);\n    }\n  }\n  dequeue() {\n    var _this$items$shift;\n    return (_this$items$shift = this.items.shift()) === null || _this$items$shift === void 0 ? void 0 : _this$items$shift.element;\n  }\n  isEmpty() {\n    return this.items.length === 0;\n  }\n  size() {\n    return this.items.length;\n  }\n}\n\n/**\n * Generates a maze using Prim's algorithm with animation\n * Creates a maze where walls define the structure and open areas are walkable paths\n * @param {number} gridSize - The size of the grid (gridSize x gridSize)\n * @param {Function} updateWalls - Callback to update UI with current walls\n * @param {Function} updateMazeGeneration - Callback to update UI with maze generation cells\n * @param {number} animationSpeed - Speed of animation in milliseconds\n * @returns {Object} - Results including final walls set, passages set, and generation stats\n */\nexport const generateMazeWithPrims = async (gridSize, updateWalls, updateMazeGeneration, animationSpeed = 100) => {\n  // Initialize: Start with everything as walls, then carve passages\n  const walls = new Set();\n  const passages = new Set();\n  const visited = new Set();\n  const frontierWalls = [];\n  const mazeGenerationCells = new Set();\n\n  // Step 1: Fill entire grid with walls\n  for (let row = 0; row < gridSize; row++) {\n    for (let col = 0; col < gridSize; col++) {\n      walls.add(`${row}-${col}`);\n    }\n  }\n\n  // Step 2: Pick a random starting cell in the interior\n  const startRow = 1 + Math.floor(Math.random() * (gridSize - 2));\n  const startCol = 1 + Math.floor(Math.random() * (gridSize - 2));\n  const startCell = `${startRow}-${startCol}`;\n\n  // Step 3: Carve the starting cell (make it a passage)\n  walls.delete(startCell);\n  passages.add(startCell);\n  visited.add(startCell);\n\n  // Step 4: Add walls adjacent to the starting cell to frontier\n  addAdjacentWallsToFrontier(startRow, startCol, gridSize, visited, frontierWalls);\n  let generationSteps = 0;\n\n  // Update initial state\n  updateWalls(new Set(walls));\n  updateMazeGeneration(new Set([startCell]));\n  await sleep(animationSpeed);\n\n  // Main Prim's algorithm loop\n  while (frontierWalls.length > 0) {\n    // Pick a random frontier wall\n    const randomIndex = Math.floor(Math.random() * frontierWalls.length);\n    const [wallRow, wallCol] = frontierWalls.splice(randomIndex, 1)[0];\n    const wallCell = `${wallRow}-${wallCol}`;\n\n    // Get adjacent cells that are already passages\n    const adjacentPassages = getAdjacentPassages(wallRow, wallCol, gridSize, passages);\n\n    // If this wall has exactly one adjacent passage, carve it\n    if (adjacentPassages.length === 1) {\n      // Carve this wall (make it a passage)\n      walls.delete(wallCell);\n      passages.add(wallCell);\n      visited.add(wallCell);\n      mazeGenerationCells.add(wallCell);\n\n      // Add new frontier walls\n      addAdjacentWallsToFrontier(wallRow, wallCol, gridSize, visited, frontierWalls);\n      generationSteps++;\n\n      // Update UI with animation\n      updateWalls(new Set(walls));\n      updateMazeGeneration(new Set(mazeGenerationCells));\n      await sleep(animationSpeed);\n    }\n  }\n\n  // Clear maze generation cells after a delay\n  setTimeout(() => {\n    updateMazeGeneration(new Set());\n  }, 1500);\n  return {\n    walls: new Set(walls),\n    passages: new Set(passages),\n    generationSteps,\n    visitedCells: passages.size\n  };\n};\n\n/**\n * Add adjacent walls to the frontier list\n */\nfunction addAdjacentWallsToFrontier(row, col, gridSize, visited, frontierWalls) {\n  const directions = [[-1, 0],\n  // up\n  [1, 0],\n  // down\n  [0, -1],\n  // left\n  [0, 1] // right\n  ];\n  for (const [dRow, dCol] of directions) {\n    const newRow = row + dRow;\n    const newCol = col + dCol;\n\n    // Check bounds (stay within grid)\n    if (newRow > 0 && newRow < gridSize - 1 && newCol > 0 && newCol < gridSize - 1) {\n      const cellKey = `${newRow}-${newCol}`;\n\n      // Only add walls that haven't been visited and aren't already in frontier\n      if (!visited.has(cellKey)) {\n        const alreadyInFrontier = frontierWalls.some(([r, c]) => r === newRow && c === newCol);\n        if (!alreadyInFrontier) {\n          frontierWalls.push([newRow, newCol]);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Get adjacent passage cells (cells that are already passages)\n */\nfunction getAdjacentPassages(row, col, gridSize, passages) {\n  const directions = [[-1, 0],\n  // up\n  [1, 0],\n  // down\n  [0, -1],\n  // left\n  [0, 1] // right\n  ];\n  const adjacentPassages = [];\n  for (const [dRow, dCol] of directions) {\n    const newRow = row + dRow;\n    const newCol = col + dCol;\n\n    // Check bounds and if it's a passage\n    if (newRow >= 0 && newRow < gridSize && newCol >= 0 && newCol < gridSize && passages.has(`${newRow}-${newCol}`)) {\n      adjacentPassages.push(`${newRow}-${newCol}`);\n    }\n  }\n  return adjacentPassages;\n}\n\n/**\n * Clean up the maze to ensure proper structure\n */\nfunction cleanupMaze(walls, gridSize) {\n  const finalWalls = new Set(walls);\n\n  // Ensure border walls\n  for (let i = 0; i < gridSize; i++) {\n    finalWalls.add(`0-${i}`); // Top border\n    finalWalls.add(`${gridSize - 1}-${i}`); // Bottom border\n    finalWalls.add(`${i}-0`); // Left border\n    finalWalls.add(`${i}-${gridSize - 1}`); // Right border\n  }\n  return finalWalls;\n}\n\n/**\n * Sleep function for animation delays\n */\nfunction sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n/**\n * Generate maze steps for step-by-step visualization\n * Returns an array of steps that can be played back\n * This is a simplified version for potential future use\n */\nexport const getPrimsMazeSteps = gridSize => {\n  const steps = [];\n  const walls = new Set();\n  const passages = new Set();\n  const frontierCells = [];\n\n  // Initialize: Start with all cells as walls\n  for (let row = 0; row < gridSize; row++) {\n    for (let col = 0; col < gridSize; col++) {\n      walls.add(`${row}-${col}`);\n    }\n  }\n\n  // Pick a random starting cell\n  const startRow = 2 + Math.floor(Math.random() * (gridSize - 4));\n  const startCol = 2 + Math.floor(Math.random() * (gridSize - 4));\n  const startCell = `${startRow}-${startCol}`;\n\n  // Make starting cell a passage\n  walls.delete(startCell);\n  passages.add(startCell);\n\n  // Add neighbors to frontier\n  addNeighborsToFrontier(startRow, startCol, gridSize, walls, passages, frontierCells);\n  steps.push({\n    walls: new Set(walls),\n    passages: new Set(passages),\n    action: 'start',\n    cell: startCell\n  });\n\n  // Generate steps\n  while (frontierCells.length > 0) {\n    const randomIndex = Math.floor(Math.random() * frontierCells.length);\n    const [currentRow, currentCol] = frontierCells.splice(randomIndex, 1)[0];\n    const currentCell = `${currentRow}-${currentCol}`;\n    if (passages.has(currentCell)) continue;\n    const adjacentPassages = getAdjacentPassageCells(currentRow, currentCol, gridSize, passages);\n    if (adjacentPassages.length > 0) {\n      walls.delete(currentCell);\n      passages.add(currentCell);\n\n      // Connect to adjacent passage\n      const connectTo = adjacentPassages[Math.floor(Math.random() * adjacentPassages.length)];\n      const [connectRow, connectCol] = connectTo.split('-').map(Number);\n      const midRow = Math.floor((currentRow + connectRow) / 2);\n      const midCol = Math.floor((currentCol + connectCol) / 2);\n      const midCell = `${midRow}-${midCol}`;\n      if (walls.has(midCell)) {\n        walls.delete(midCell);\n        passages.add(midCell);\n      }\n      addNeighborsToFrontier(currentRow, currentCol, gridSize, walls, passages, frontierCells);\n      steps.push({\n        walls: new Set(walls),\n        passages: new Set(passages),\n        action: 'carve',\n        cell: currentCell\n      });\n    }\n  }\n  steps.push({\n    walls: new Set(walls),\n    passages: new Set(passages),\n    action: 'complete',\n    cell: null\n  });\n  return steps;\n};\nexport default generateMazeWithPrims;","map":{"version":3,"names":["PriorityQueue","constructor","items","enqueue","element","priority","Math","random","queueElement","added","i","length","splice","push","dequeue","_this$items$shift","shift","isEmpty","size","generateMazeWithPrims","gridSize","updateWalls","updateMazeGeneration","animationSpeed","walls","Set","passages","visited","frontierWalls","mazeGenerationCells","row","col","add","startRow","floor","startCol","startCell","delete","addAdjacentWallsToFrontier","generationSteps","sleep","randomIndex","wallRow","wallCol","wallCell","adjacentPassages","getAdjacentPassages","setTimeout","visitedCells","directions","dRow","dCol","newRow","newCol","cellKey","has","alreadyInFrontier","some","r","c","cleanupMaze","finalWalls","ms","Promise","resolve","getPrimsMazeSteps","steps","frontierCells","addNeighborsToFrontier","action","cell","currentRow","currentCol","currentCell","getAdjacentPassageCells","connectTo","connectRow","connectCol","split","map","Number","midRow","midCol","midCell"],"sources":["E:/maze_analyser/src/algorithms/primsAlgorithm.js"],"sourcesContent":["/**\n * Prim's Algorithm for Maze Generation\n * \n * This algorithm generates a maze by starting with a grid full of walls and \n * carving out passages using Prim's minimum spanning tree algorithm.\n * \n * Data Structures Used:\n * - Set: For tracking visited cells and walls\n * - Array: For frontier walls (acts as a priority queue)\n * - Map: For parent tracking during generation\n */\n\n/**\n * Priority Queue implementation using array for Prim's algorithm\n */\nclass PriorityQueue {\n  constructor() {\n    this.items = [];\n  }\n\n  enqueue(element, priority = Math.random()) {\n    const queueElement = { element, priority };\n    let added = false;\n\n    for (let i = 0; i < this.items.length; i++) {\n      if (queueElement.priority < this.items[i].priority) {\n        this.items.splice(i, 0, queueElement);\n        added = true;\n        break;\n      }\n    }\n\n    if (!added) {\n      this.items.push(queueElement);\n    }\n  }\n\n  dequeue() {\n    return this.items.shift()?.element;\n  }\n\n  isEmpty() {\n    return this.items.length === 0;\n  }\n\n  size() {\n    return this.items.length;\n  }\n}\n\n/**\n * Generates a maze using Prim's algorithm with animation\n * Creates a maze where walls define the structure and open areas are walkable paths\n * @param {number} gridSize - The size of the grid (gridSize x gridSize)\n * @param {Function} updateWalls - Callback to update UI with current walls\n * @param {Function} updateMazeGeneration - Callback to update UI with maze generation cells\n * @param {number} animationSpeed - Speed of animation in milliseconds\n * @returns {Object} - Results including final walls set, passages set, and generation stats\n */\nexport const generateMazeWithPrims = async (\n  gridSize,\n  updateWalls,\n  updateMazeGeneration,\n  animationSpeed = 100\n) => {\n  // Initialize: Start with everything as walls, then carve passages\n  const walls = new Set();\n  const passages = new Set();\n  const visited = new Set();\n  const frontierWalls = [];\n  const mazeGenerationCells = new Set();\n  \n  // Step 1: Fill entire grid with walls\n  for (let row = 0; row < gridSize; row++) {\n    for (let col = 0; col < gridSize; col++) {\n      walls.add(`${row}-${col}`);\n    }\n  }\n\n  // Step 2: Pick a random starting cell in the interior\n  const startRow = 1 + Math.floor(Math.random() * (gridSize - 2));\n  const startCol = 1 + Math.floor(Math.random() * (gridSize - 2));\n  const startCell = `${startRow}-${startCol}`;\n  \n  // Step 3: Carve the starting cell (make it a passage)\n  walls.delete(startCell);\n  passages.add(startCell);\n  visited.add(startCell);\n  \n  // Step 4: Add walls adjacent to the starting cell to frontier\n  addAdjacentWallsToFrontier(startRow, startCol, gridSize, visited, frontierWalls);\n  \n  let generationSteps = 0;\n  \n  // Update initial state\n  updateWalls(new Set(walls));\n  updateMazeGeneration(new Set([startCell]));\n  await sleep(animationSpeed);\n\n  // Main Prim's algorithm loop\n  while (frontierWalls.length > 0) {\n    // Pick a random frontier wall\n    const randomIndex = Math.floor(Math.random() * frontierWalls.length);\n    const [wallRow, wallCol] = frontierWalls.splice(randomIndex, 1)[0];\n    const wallCell = `${wallRow}-${wallCol}`;\n    \n    // Get adjacent cells that are already passages\n    const adjacentPassages = getAdjacentPassages(wallRow, wallCol, gridSize, passages);\n    \n    // If this wall has exactly one adjacent passage, carve it\n    if (adjacentPassages.length === 1) {\n      // Carve this wall (make it a passage)\n      walls.delete(wallCell);\n      passages.add(wallCell);\n      visited.add(wallCell);\n      mazeGenerationCells.add(wallCell);\n      \n      // Add new frontier walls\n      addAdjacentWallsToFrontier(wallRow, wallCol, gridSize, visited, frontierWalls);\n      \n      generationSteps++;\n      \n      // Update UI with animation\n      updateWalls(new Set(walls));\n      updateMazeGeneration(new Set(mazeGenerationCells));\n      await sleep(animationSpeed);\n    }\n  }\n\n  // Clear maze generation cells after a delay\n  setTimeout(() => {\n    updateMazeGeneration(new Set());\n  }, 1500);\n  \n  return {\n    walls: new Set(walls),\n    passages: new Set(passages),\n    generationSteps,\n    visitedCells: passages.size\n  };\n};\n\n/**\n * Add adjacent walls to the frontier list\n */\nfunction addAdjacentWallsToFrontier(row, col, gridSize, visited, frontierWalls) {\n  const directions = [\n    [-1, 0], // up\n    [1, 0],  // down\n    [0, -1], // left\n    [0, 1]   // right\n  ];\n  \n  for (const [dRow, dCol] of directions) {\n    const newRow = row + dRow;\n    const newCol = col + dCol;\n    \n    // Check bounds (stay within grid)\n    if (newRow > 0 && newRow < gridSize - 1 && newCol > 0 && newCol < gridSize - 1) {\n      const cellKey = `${newRow}-${newCol}`;\n      \n      // Only add walls that haven't been visited and aren't already in frontier\n      if (!visited.has(cellKey)) {\n        const alreadyInFrontier = frontierWalls.some(([r, c]) => r === newRow && c === newCol);\n        if (!alreadyInFrontier) {\n          frontierWalls.push([newRow, newCol]);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Get adjacent passage cells (cells that are already passages)\n */\nfunction getAdjacentPassages(row, col, gridSize, passages) {\n  const directions = [\n    [-1, 0], // up\n    [1, 0],  // down\n    [0, -1], // left\n    [0, 1]   // right\n  ];\n  \n  const adjacentPassages = [];\n  \n  for (const [dRow, dCol] of directions) {\n    const newRow = row + dRow;\n    const newCol = col + dCol;\n    \n    // Check bounds and if it's a passage\n    if (\n      newRow >= 0 && newRow < gridSize &&\n      newCol >= 0 && newCol < gridSize &&\n      passages.has(`${newRow}-${newCol}`)\n    ) {\n      adjacentPassages.push(`${newRow}-${newCol}`);\n    }\n  }\n  \n  return adjacentPassages;\n}\n\n/**\n * Clean up the maze to ensure proper structure\n */\nfunction cleanupMaze(walls, gridSize) {\n  const finalWalls = new Set(walls);\n  \n  // Ensure border walls\n  for (let i = 0; i < gridSize; i++) {\n    finalWalls.add(`0-${i}`); // Top border\n    finalWalls.add(`${gridSize - 1}-${i}`); // Bottom border\n    finalWalls.add(`${i}-0`); // Left border\n    finalWalls.add(`${i}-${gridSize - 1}`); // Right border\n  }\n  \n  return finalWalls;\n}\n\n/**\n * Sleep function for animation delays\n */\nfunction sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n/**\n * Generate maze steps for step-by-step visualization\n * Returns an array of steps that can be played back\n * This is a simplified version for potential future use\n */\nexport const getPrimsMazeSteps = (gridSize) => {\n  const steps = [];\n  const walls = new Set();\n  const passages = new Set();\n  const frontierCells = [];\n  \n  // Initialize: Start with all cells as walls\n  for (let row = 0; row < gridSize; row++) {\n    for (let col = 0; col < gridSize; col++) {\n      walls.add(`${row}-${col}`);\n    }\n  }\n\n  // Pick a random starting cell\n  const startRow = 2 + Math.floor(Math.random() * (gridSize - 4));\n  const startCol = 2 + Math.floor(Math.random() * (gridSize - 4));\n  const startCell = `${startRow}-${startCol}`;\n  \n  // Make starting cell a passage\n  walls.delete(startCell);\n  passages.add(startCell);\n  \n  // Add neighbors to frontier\n  addNeighborsToFrontier(startRow, startCol, gridSize, walls, passages, frontierCells);\n  \n  steps.push({\n    walls: new Set(walls),\n    passages: new Set(passages),\n    action: 'start',\n    cell: startCell\n  });\n\n  // Generate steps\n  while (frontierCells.length > 0) {\n    const randomIndex = Math.floor(Math.random() * frontierCells.length);\n    const [currentRow, currentCol] = frontierCells.splice(randomIndex, 1)[0];\n    const currentCell = `${currentRow}-${currentCol}`;\n    \n    if (passages.has(currentCell)) continue;\n    \n    const adjacentPassages = getAdjacentPassageCells(currentRow, currentCol, gridSize, passages);\n    \n    if (adjacentPassages.length > 0) {\n      walls.delete(currentCell);\n      passages.add(currentCell);\n      \n      // Connect to adjacent passage\n      const connectTo = adjacentPassages[Math.floor(Math.random() * adjacentPassages.length)];\n      const [connectRow, connectCol] = connectTo.split('-').map(Number);\n      \n      const midRow = Math.floor((currentRow + connectRow) / 2);\n      const midCol = Math.floor((currentCol + connectCol) / 2);\n      const midCell = `${midRow}-${midCol}`;\n      \n      if (walls.has(midCell)) {\n        walls.delete(midCell);\n        passages.add(midCell);\n      }\n      \n      addNeighborsToFrontier(currentRow, currentCol, gridSize, walls, passages, frontierCells);\n      \n      steps.push({\n        walls: new Set(walls),\n        passages: new Set(passages),\n        action: 'carve',\n        cell: currentCell\n      });\n    }\n  }\n\n  steps.push({\n    walls: new Set(walls),\n    passages: new Set(passages),\n    action: 'complete',\n    cell: null\n  });\n\n  return steps;\n};\n\nexport default generateMazeWithPrims;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}