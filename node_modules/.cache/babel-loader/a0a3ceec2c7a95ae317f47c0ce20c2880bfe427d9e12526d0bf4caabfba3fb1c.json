{"ast":null,"code":"/**\n * Simple Prim's Algorithm for Maze Generation\n */\n\n/**\n * Generates a maze using Prim's algorithm\n * @param {number} gridSize - The size of the grid\n * @param {Function} updateWalls - Callback to update UI with current walls\n * @param {Function} updateMazeGeneration - Callback to update UI with maze generation cells\n * @param {number} animationSpeed - Speed of animation in milliseconds\n * @returns {Object} - Results including final walls set and generation stats\n */\nexport const generateMazeWithPrims = async (gridSize, updateWalls, updateMazeGeneration, animationSpeed = 150) => {\n  // Initialize: Start with empty grid (all passages)\n  const walls = new Set();\n  const passages = new Set();\n  const visited = new Set();\n  const frontierWalls = [];\n  const mazeGenerationCells = new Set();\n\n  // Step 1: Start with empty grid - all cells are initially passages\n  for (let row = 0; row < gridSize; row++) {\n    for (let col = 0; col < gridSize; col++) {\n      passages.add(`${row}-${col}`);\n    }\n  }\n\n  // Step 2: Start from top-left corner (1,1 to avoid border)\n  const startRow = 1;\n  const startCol = 1;\n  const startCell = `${startRow}-${startCol}`;\n\n  // Step 3: Mark starting cell as visited\n  visited.add(startCell);\n\n  // Add initial frontier walls\n  if (startRow > 1) frontierWalls.push(`${startRow - 1}-${startCol}`);\n  if (startRow < gridSize - 2) frontierWalls.push(`${startRow + 1}-${startCol}`);\n  if (startCol > 1) frontierWalls.push(`${startRow}-${startCol - 1}`);\n  if (startCol < gridSize - 2) frontierWalls.push(`${startRow}-${startCol + 1}`);\n\n  // Rest of the algorithm implementation goes here...\n\n  updateWalls(new Set(walls));\n  return {\n    walls: new Set(walls),\n    generationSteps: walls.size,\n    visitedCells: gridSize * gridSize - walls.size\n  };\n};\nexport default generateMazeWithPrims;","map":{"version":3,"names":["generateMazeWithPrims","gridSize","updateWalls","updateMazeGeneration","animationSpeed","walls","Set","passages","visited","frontierWalls","mazeGenerationCells","row","col","add","startRow","startCol","startCell","push","generationSteps","size","visitedCells"],"sources":["E:/maze_analyser/src/algorithms/primsAlgorithm.js"],"sourcesContent":["/**\n * Simple Prim's Algorithm for Maze Generation\n */\n\n/**\n * Generates a maze using Prim's algorithm\n * @param {number} gridSize - The size of the grid\n * @param {Function} updateWalls - Callback to update UI with current walls\n * @param {Function} updateMazeGeneration - Callback to update UI with maze generation cells\n * @param {number} animationSpeed - Speed of animation in milliseconds\n * @returns {Object} - Results including final walls set and generation stats\n */\nexport const generateMazeWithPrims = async (\n  gridSize,\n  updateWalls,\n  updateMazeGeneration,\n  animationSpeed = 150\n) => {\n  // Initialize: Start with empty grid (all passages)\n  const walls = new Set();\n  const passages = new Set();\n  const visited = new Set();\n  const frontierWalls = [];\n  const mazeGenerationCells = new Set();\n  \n  // Step 1: Start with empty grid - all cells are initially passages\n  for (let row = 0; row < gridSize; row++) {\n    for (let col = 0; col < gridSize; col++) {\n      passages.add(`${row}-${col}`);\n    }\n  }\n  \n  // Step 2: Start from top-left corner (1,1 to avoid border)\n  const startRow = 1;\n  const startCol = 1;\n  const startCell = `${startRow}-${startCol}`;\n  \n  // Step 3: Mark starting cell as visited\n  visited.add(startCell);\n  \n  // Add initial frontier walls\n  if (startRow > 1) frontierWalls.push(`${startRow - 1}-${startCol}`);\n  if (startRow < gridSize - 2) frontierWalls.push(`${startRow + 1}-${startCol}`);\n  if (startCol > 1) frontierWalls.push(`${startRow}-${startCol - 1}`);\n  if (startCol < gridSize - 2) frontierWalls.push(`${startRow}-${startCol + 1}`);\n  \n  // Rest of the algorithm implementation goes here...\n  \n  updateWalls(new Set(walls));\n  \n  return {\n    walls: new Set(walls),\n    generationSteps: walls.size,\n    visitedCells: gridSize * gridSize - walls.size\n  };\n};\n\nexport default generateMazeWithPrims;\n"],"mappings":"AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMA,qBAAqB,GAAG,MAAAA,CACnCC,QAAQ,EACRC,WAAW,EACXC,oBAAoB,EACpBC,cAAc,GAAG,GAAG,KACjB;EACH;EACA,MAAMC,KAAK,GAAG,IAAIC,GAAG,CAAC,CAAC;EACvB,MAAMC,QAAQ,GAAG,IAAID,GAAG,CAAC,CAAC;EAC1B,MAAME,OAAO,GAAG,IAAIF,GAAG,CAAC,CAAC;EACzB,MAAMG,aAAa,GAAG,EAAE;EACxB,MAAMC,mBAAmB,GAAG,IAAIJ,GAAG,CAAC,CAAC;;EAErC;EACA,KAAK,IAAIK,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGV,QAAQ,EAAEU,GAAG,EAAE,EAAE;IACvC,KAAK,IAAIC,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGX,QAAQ,EAAEW,GAAG,EAAE,EAAE;MACvCL,QAAQ,CAACM,GAAG,CAAC,GAAGF,GAAG,IAAIC,GAAG,EAAE,CAAC;IAC/B;EACF;;EAEA;EACA,MAAME,QAAQ,GAAG,CAAC;EAClB,MAAMC,QAAQ,GAAG,CAAC;EAClB,MAAMC,SAAS,GAAG,GAAGF,QAAQ,IAAIC,QAAQ,EAAE;;EAE3C;EACAP,OAAO,CAACK,GAAG,CAACG,SAAS,CAAC;;EAEtB;EACA,IAAIF,QAAQ,GAAG,CAAC,EAAEL,aAAa,CAACQ,IAAI,CAAC,GAAGH,QAAQ,GAAG,CAAC,IAAIC,QAAQ,EAAE,CAAC;EACnE,IAAID,QAAQ,GAAGb,QAAQ,GAAG,CAAC,EAAEQ,aAAa,CAACQ,IAAI,CAAC,GAAGH,QAAQ,GAAG,CAAC,IAAIC,QAAQ,EAAE,CAAC;EAC9E,IAAIA,QAAQ,GAAG,CAAC,EAAEN,aAAa,CAACQ,IAAI,CAAC,GAAGH,QAAQ,IAAIC,QAAQ,GAAG,CAAC,EAAE,CAAC;EACnE,IAAIA,QAAQ,GAAGd,QAAQ,GAAG,CAAC,EAAEQ,aAAa,CAACQ,IAAI,CAAC,GAAGH,QAAQ,IAAIC,QAAQ,GAAG,CAAC,EAAE,CAAC;;EAE9E;;EAEAb,WAAW,CAAC,IAAII,GAAG,CAACD,KAAK,CAAC,CAAC;EAE3B,OAAO;IACLA,KAAK,EAAE,IAAIC,GAAG,CAACD,KAAK,CAAC;IACrBa,eAAe,EAAEb,KAAK,CAACc,IAAI;IAC3BC,YAAY,EAAEnB,QAAQ,GAAGA,QAAQ,GAAGI,KAAK,CAACc;EAC5C,CAAC;AACH,CAAC;AAED,eAAenB,qBAAqB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}