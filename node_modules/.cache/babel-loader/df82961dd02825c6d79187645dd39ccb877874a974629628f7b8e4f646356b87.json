{"ast":null,"code":"/**\n * Depth-First Search (DFS) Algorithm Implementation with Top-Down Priority\n * \n * This implementation ensures DFS explores downward first before other directions,\n * creating a more predictable top-down exploration pattern.\n */\n\n/**\n * Implements the Depth-First Search algorithm with top-down priority\n * @param {number} gridSize - The size of the grid (gridSize x gridSize)\n * @param {Object} startPos - The starting position {row, col}\n * @param {Object} targetPos - The target position {row, col}\n * @param {Set} walls - Set of wall positions in \"row-col\" format\n * @param {Function} updateVisited - Callback to update UI with visited cells\n * @param {Function} updatePath - Callback to update UI with final path\n * @returns {Object} - Results including whether path was found, path, visited nodes count\n */\nconst depthFirstSearchTopDown = async (gridSize, startPos, targetPos, walls, updateVisited, updatePath) => {\n  const stack = [];\n  const visited = new Set();\n  const parent = new Map();\n  let pathFound = false;\n  let visitedCount = 0;\n  const startPosStr = `${startPos.row}-${startPos.col}`;\n  const targetPosStr = `${targetPos.row}-${targetPos.col}`;\n\n  // Check if start is the same as target\n  if (startPosStr === targetPosStr) {\n    return {\n      pathFound: true,\n      path: [{\n        row: startPos.row,\n        col: startPos.col\n      }],\n      visitedCount: 1,\n      pathLength: 1,\n      success: true,\n      executionTime: 0\n    };\n  }\n\n  // Initialize with start position\n  stack.push(startPosStr);\n\n  // Directions in order of priority: down, up, right, left\n  // This ensures we always prioritize vertical movement (top-down)\n  const directions = [[1, 0],\n  // down (highest priority)\n  [-1, 0],\n  // up (second priority - still vertical)\n  [0, 1],\n  // right\n  [0, -1] // left\n  ];\n\n  // For visualization delay\n  const delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n  // Main DFS loop\n  while (stack.length > 0) {\n    const current = stack.pop();\n\n    // Skip if already visited\n    if (visited.has(current)) continue;\n    const [currentRow, currentCol] = current.split('-').map(Number);\n    visited.add(current);\n    visitedCount++;\n\n    // Check if target found\n    if (current === targetPosStr) {\n      pathFound = true;\n      break;\n    }\n\n    // Update UI for visited cell\n    if (updateVisited && current !== startPosStr) {\n      updateVisited(currentRow, currentCol);\n      // Only delay every 3rd cell for better performance\n      if (visitedCount % 3 === 0) {\n        await delay(1);\n      }\n    }\n\n    // Process neighbors in reverse order (since we're using a stack)\n    // This ensures vertical movement is always prioritized (down first, then up)\n    // before horizontal movement (right, then left)\n    for (let i = directions.length - 1; i >= 0; i--) {\n      const [dx, dy] = directions[i];\n      const newRow = currentRow + dx;\n      const newCol = currentCol + dy;\n      if (newRow >= 0 && newRow < gridSize && newCol >= 0 && newCol < gridSize) {\n        const newPos = `${newRow}-${newCol}`;\n        if (!walls.has(newPos) && !visited.has(newPos)) {\n          stack.push(newPos);\n          if (!parent.has(newPos)) {\n            parent.set(newPos, current);\n          }\n        }\n      }\n    }\n  }\n\n  // Reconstruct the path if target was found\n  const path = [];\n  if (pathFound) {\n    let current = targetPosStr;\n\n    // Work backward from target to start\n    while (current !== startPosStr) {\n      const [row, col] = current.split('-').map(Number);\n      path.unshift({\n        row,\n        col\n      });\n      current = parent.get(current);\n    }\n\n    // Update UI with the final path\n    if (updatePath) {\n      for (const {\n        row,\n        col\n      } of path) {\n        updatePath(row, col);\n        await delay(50); // Slightly longer delay for path visualization\n      }\n    }\n  }\n  return {\n    pathFound,\n    path,\n    visitedCount,\n    pathLength: path.length,\n    success: pathFound,\n    executionTime: 0 // This will be calculated by the caller\n  };\n};\n\n// Export both named and default for compatibility\nexport { depthFirstSearchTopDown };\nexport default depthFirstSearchTopDown;","map":{"version":3,"names":["depthFirstSearchTopDown","gridSize","startPos","targetPos","walls","updateVisited","updatePath","stack","visited","Set","parent","Map","pathFound","visitedCount","startPosStr","row","col","targetPosStr","path","pathLength","success","executionTime","push","directions","delay","ms","Promise","resolve","setTimeout","length","current","pop","has","currentRow","currentCol","split","map","Number","add","i","dx","dy","newRow","newCol","newPos","set","unshift","get"],"sources":["E:/maze_analyser/src/algorithms/dfsTopDown.js"],"sourcesContent":["/**\n * Depth-First Search (DFS) Algorithm Implementation with Top-Down Priority\n * \n * This implementation ensures DFS explores downward first before other directions,\n * creating a more predictable top-down exploration pattern.\n */\n\n/**\n * Implements the Depth-First Search algorithm with top-down priority\n * @param {number} gridSize - The size of the grid (gridSize x gridSize)\n * @param {Object} startPos - The starting position {row, col}\n * @param {Object} targetPos - The target position {row, col}\n * @param {Set} walls - Set of wall positions in \"row-col\" format\n * @param {Function} updateVisited - Callback to update UI with visited cells\n * @param {Function} updatePath - Callback to update UI with final path\n * @returns {Object} - Results including whether path was found, path, visited nodes count\n */\nconst depthFirstSearchTopDown = async (\n  gridSize,\n  startPos,\n  targetPos,\n  walls,\n  updateVisited,\n  updatePath\n) => {\n  const stack = [];\n  const visited = new Set();\n  const parent = new Map();\n  let pathFound = false;\n  let visitedCount = 0;\n  \n  const startPosStr = `${startPos.row}-${startPos.col}`;\n  const targetPosStr = `${targetPos.row}-${targetPos.col}`;\n  \n  // Check if start is the same as target\n  if (startPosStr === targetPosStr) {\n    return {\n      pathFound: true,\n      path: [{ row: startPos.row, col: startPos.col }],\n      visitedCount: 1,\n      pathLength: 1,\n      success: true,\n      executionTime: 0\n    };\n  }\n  \n  // Initialize with start position\n  stack.push(startPosStr);\n  \n  // Directions in order of priority: down, up, right, left\n  // This ensures we always prioritize vertical movement (top-down)\n  const directions = [\n    [1, 0],   // down (highest priority)\n    [-1, 0],  // up (second priority - still vertical)\n    [0, 1],   // right\n    [0, -1]   // left\n  ];\n  \n  // For visualization delay\n  const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));\n  \n  // Main DFS loop\n  while (stack.length > 0) {\n    const current = stack.pop();\n    \n    // Skip if already visited\n    if (visited.has(current)) continue;\n    \n    const [currentRow, currentCol] = current.split('-').map(Number);\n    visited.add(current);\n    visitedCount++;\n    \n    // Check if target found\n    if (current === targetPosStr) {\n      pathFound = true;\n      break;\n    }\n    \n    // Update UI for visited cell\n    if (updateVisited && current !== startPosStr) {\n      updateVisited(currentRow, currentCol);\n      // Only delay every 3rd cell for better performance\n      if (visitedCount % 3 === 0) {\n        await delay(1);\n      }\n    }\n    \n    // Process neighbors in reverse order (since we're using a stack)\n    // This ensures vertical movement is always prioritized (down first, then up)\n    // before horizontal movement (right, then left)\n    for (let i = directions.length - 1; i >= 0; i--) {\n      const [dx, dy] = directions[i];\n      const newRow = currentRow + dx;\n      const newCol = currentCol + dy;\n      \n      if (newRow >= 0 && newRow < gridSize && \n          newCol >= 0 && newCol < gridSize) {\n        \n        const newPos = `${newRow}-${newCol}`;\n        \n        if (!walls.has(newPos) && !visited.has(newPos)) {\n          stack.push(newPos);\n          if (!parent.has(newPos)) {\n            parent.set(newPos, current);\n          }\n        }\n      }\n    }\n  }\n  \n  // Reconstruct the path if target was found\n  const path = [];\n  if (pathFound) {\n    let current = targetPosStr;\n    \n    // Work backward from target to start\n    while (current !== startPosStr) {\n      const [row, col] = current.split('-').map(Number);\n      path.unshift({ row, col });\n      current = parent.get(current);\n    }\n    \n    // Update UI with the final path\n    if (updatePath) {\n      for (const { row, col } of path) {\n        updatePath(row, col);\n        await delay(50); // Slightly longer delay for path visualization\n      }\n    }\n  }\n  \n  return {\n    pathFound,\n    path,\n    visitedCount,\n    pathLength: path.length,\n    success: pathFound,\n    executionTime: 0 // This will be calculated by the caller\n  };\n};\n\n// Export both named and default for compatibility\nexport { depthFirstSearchTopDown };\nexport default depthFirstSearchTopDown;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}