{"ast":null,"code":"/**\n * Proper Prim's Algorithm for Maze Generation with Animation\n * Fixed: Starts from top-left, correct wall/passage logic with color swapping\n */\n\n// Helper function to add delay for animation\nconst sleep = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n/**\n * Generates a maze using Prim's algorithm with step-by-step animation\n * @param {number} gridSize - The size of the grid\n * @param {Function} updateWalls - Callback to update UI with current walls\n * @param {Function} updateMazeGeneration - Callback to update UI with maze generation cells\n * @param {number} animationSpeed - Speed of animation in milliseconds\n * @returns {Object} - Results including final walls set and generation stats\n */\nexport const generateMazeWithPrims = async (gridSize,\n// Maximum speed generation\nupdateWalls, updateMazeGeneration, animationSpeed = 1 // Minimal delay for UI updates\n) => {\n  // Initialize: Start with empty grid, then add walls to create maze\n  const walls = new Set();\n  const visited = new Set();\n  const frontierCells = [];\n  const mazeGenerationCells = new Set();\n  let generationSteps = 0;\n  let lastRenderTime = Date.now(); // Track last render time for FPS control\n\n  // Step 1: Start from top-left corner (1,1 to leave border space)\n  const startRow = 1;\n  const startCol = 1;\n  const startCell = {\n    row: startRow,\n    col: startCol\n  };\n\n  // Mark start cell as visited\n  const startKey = `${startRow}-${startCol}`;\n  visited.add(startKey);\n  mazeGenerationCells.add(startKey);\n\n  // Step 3: Add neighboring cells to frontier\n  const addNeighborsToFrontier = (row, col) => {\n    const neighbors = [[row - 2, col], [row + 2, col],\n    // Vertical neighbors (2 steps for proper maze)\n    [row, col - 2], [row, col + 2] // Horizontal neighbors (2 steps for proper maze)\n    ];\n    for (const [newRow, newCol] of neighbors) {\n      if (newRow > 0 && newRow < gridSize - 1 && newCol > 0 && newCol < gridSize - 1) {\n        const cellKey = `${newRow}-${newCol}`;\n        if (!visited.has(cellKey) && !frontierCells.some(([r, c]) => r === newRow && c === newCol)) {\n          frontierCells.push([newRow, newCol]);\n        }\n      }\n    }\n  };\n  addNeighborsToFrontier(startRow, startCol);\n\n  // Update initial state\n  updateWalls(new Set(walls));\n  updateMazeGeneration(new Set(mazeGenerationCells));\n  await sleep(animationSpeed);\n\n  // Main Prim's algorithm loop\n  while (frontierCells.length > 0) {\n    // Pick a random frontier cell\n    const randomIndex = Math.floor(Math.random() * frontierCells.length);\n    const [cellRow, cellCol] = frontierCells.splice(randomIndex, 1)[0];\n    const cellKey = `${cellRow}-${cellCol}`;\n\n    // Find visited neighbors of this frontier cell\n    const visitedNeighbors = [];\n    const neighborDirections = [[cellRow - 2, cellCol], [cellRow + 2, cellCol], [cellRow, cellCol - 2], [cellRow, cellCol + 2]];\n    for (const [nRow, nCol] of neighborDirections) {\n      if (nRow >= 0 && nRow < gridSize && nCol >= 0 && nCol < gridSize) {\n        if (visited.has(`${nRow}-${nCol}`)) {\n          visitedNeighbors.push([nRow, nCol]);\n        }\n      }\n    }\n\n    // If this frontier cell has visited neighbors, connect it\n    if (visitedNeighbors.length > 0) {\n      // Mark this cell as visited (it becomes a passage during generation)\n      visited.add(cellKey);\n      mazeGenerationCells.add(cellKey);\n\n      // Connect to a random visited neighbor by removing the wall between them\n      const [neighborRow, neighborCol] = visitedNeighbors[Math.floor(Math.random() * visitedNeighbors.length)];\n      const wallRow = (cellRow + neighborRow) / 2;\n      const wallCol = (cellCol + neighborCol) / 2;\n      const wallKey = `${wallRow}-${wallCol}`;\n\n      // The wall between them should also be a passage during generation\n      visited.add(wallKey);\n      mazeGenerationCells.add(wallKey);\n\n      // Add new frontier cells\n      addNeighborsToFrontier(cellRow, cellCol);\n      generationSteps++;\n\n      // Update UI at most 30 times per second for smooth animation\n      if (Date.now() - lastRenderTime > 33) {\n        // ~30fps\n        updateWalls(new Set(walls));\n        updateMazeGeneration(new Set(mazeGenerationCells));\n        lastRenderTime = Date.now();\n        // Small delay to prevent UI freezing\n        await new Promise(resolve => setTimeout(resolve, 0));\n      }\n    }\n  }\n\n  // Step 4: Track all visited cells as part of the final path\n  const finalPathCells = new Set(visited);\n\n  // After generation, we'll swap colors:\n  // - Final path cells (visited) will be light\n  // - All other cells will be dark/black\n\n  // Final update with complete walls\n  updateWalls(new Set(walls));\n\n  // Signal that generation is complete and force immediate UI update\n  updateWalls(new Set(walls));\n  updateMazeGeneration(new Set(['generation_complete']));\n  return {\n    walls: new Set(walls),\n    generationSteps,\n    visitedCells: visited.size\n  };\n};\nexport default generateMazeWithPrims;","map":{"version":3,"names":["sleep","ms","Promise","resolve","setTimeout","generateMazeWithPrims","gridSize","updateWalls","updateMazeGeneration","animationSpeed","walls","Set","visited","frontierCells","mazeGenerationCells","generationSteps","lastRenderTime","Date","now","startRow","startCol","startCell","row","col","startKey","add","addNeighborsToFrontier","neighbors","newRow","newCol","cellKey","has","some","r","c","push","length","randomIndex","Math","floor","random","cellRow","cellCol","splice","visitedNeighbors","neighborDirections","nRow","nCol","neighborRow","neighborCol","wallRow","wallCol","wallKey","finalPathCells","visitedCells","size"],"sources":["E:/maze_analyser/src/algorithms/primsAlgorithm.js"],"sourcesContent":["/**\n * Proper Prim's Algorithm for Maze Generation with Animation\n * Fixed: Starts from top-left, correct wall/passage logic with color swapping\n */\n\n// Helper function to add delay for animation\nconst sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));\n\n/**\n * Generates a maze using Prim's algorithm with step-by-step animation\n * @param {number} gridSize - The size of the grid\n * @param {Function} updateWalls - Callback to update UI with current walls\n * @param {Function} updateMazeGeneration - Callback to update UI with maze generation cells\n * @param {number} animationSpeed - Speed of animation in milliseconds\n * @returns {Object} - Results including final walls set and generation stats\n */\nexport const generateMazeWithPrims = async (\n  gridSize,\n  // Maximum speed generation\n  updateWalls,\n  updateMazeGeneration,\n  animationSpeed = 1 // Minimal delay for UI updates\n) => {\n  // Initialize: Start with empty grid, then add walls to create maze\n  const walls = new Set();\n  const visited = new Set();\n  const frontierCells = [];\n  const mazeGenerationCells = new Set();\n  let generationSteps = 0;\n  let lastRenderTime = Date.now(); // Track last render time for FPS control\n  \n  // Step 1: Start from top-left corner (1,1 to leave border space)\n  const startRow = 1;\n  const startCol = 1;\n  const startCell = { row: startRow, col: startCol };\n  \n  // Mark start cell as visited\n  const startKey = `${startRow}-${startCol}`;\n  visited.add(startKey);\n  mazeGenerationCells.add(startKey);\n  \n  // Step 3: Add neighboring cells to frontier\n  const addNeighborsToFrontier = (row, col) => {\n    const neighbors = [\n      [row - 2, col], [row + 2, col], // Vertical neighbors (2 steps for proper maze)\n      [row, col - 2], [row, col + 2]  // Horizontal neighbors (2 steps for proper maze)\n    ];\n    \n    for (const [newRow, newCol] of neighbors) {\n      if (newRow > 0 && newRow < gridSize - 1 && newCol > 0 && newCol < gridSize - 1) {\n        const cellKey = `${newRow}-${newCol}`;\n        if (!visited.has(cellKey) && !frontierCells.some(([r, c]) => r === newRow && c === newCol)) {\n          frontierCells.push([newRow, newCol]);\n        }\n      }\n    }\n  };\n  \n  addNeighborsToFrontier(startRow, startCol);\n  \n  // Update initial state\n  updateWalls(new Set(walls));\n  updateMazeGeneration(new Set(mazeGenerationCells));\n  await sleep(animationSpeed);\n\n  // Main Prim's algorithm loop\n  while (frontierCells.length > 0) {\n    // Pick a random frontier cell\n    const randomIndex = Math.floor(Math.random() * frontierCells.length);\n    const [cellRow, cellCol] = frontierCells.splice(randomIndex, 1)[0];\n    const cellKey = `${cellRow}-${cellCol}`;\n    \n    // Find visited neighbors of this frontier cell\n    const visitedNeighbors = [];\n    const neighborDirections = [\n      [cellRow - 2, cellCol], [cellRow + 2, cellCol],\n      [cellRow, cellCol - 2], [cellRow, cellCol + 2]\n    ];\n    \n    for (const [nRow, nCol] of neighborDirections) {\n      if (nRow >= 0 && nRow < gridSize && nCol >= 0 && nCol < gridSize) {\n        if (visited.has(`${nRow}-${nCol}`)) {\n          visitedNeighbors.push([nRow, nCol]);\n        }\n      }\n    }\n    \n    // If this frontier cell has visited neighbors, connect it\n    if (visitedNeighbors.length > 0) {\n      // Mark this cell as visited (it becomes a passage during generation)\n      visited.add(cellKey);\n      mazeGenerationCells.add(cellKey);\n      \n      // Connect to a random visited neighbor by removing the wall between them\n      const [neighborRow, neighborCol] = visitedNeighbors[Math.floor(Math.random() * visitedNeighbors.length)];\n      const wallRow = (cellRow + neighborRow) / 2;\n      const wallCol = (cellCol + neighborCol) / 2;\n      const wallKey = `${wallRow}-${wallCol}`;\n      \n      // The wall between them should also be a passage during generation\n      visited.add(wallKey);\n      mazeGenerationCells.add(wallKey);\n      \n      // Add new frontier cells\n      addNeighborsToFrontier(cellRow, cellCol);\n      \n      generationSteps++;\n      \n      // Update UI at most 30 times per second for smooth animation\n      if (Date.now() - lastRenderTime > 33) { // ~30fps\n        updateWalls(new Set(walls));\n        updateMazeGeneration(new Set(mazeGenerationCells));\n        lastRenderTime = Date.now();\n        // Small delay to prevent UI freezing\n        await new Promise(resolve => setTimeout(resolve, 0));\n      }\n    }\n  }\n  \n  // Step 4: Track all visited cells as part of the final path\n  const finalPathCells = new Set(visited);\n  \n  // After generation, we'll swap colors:\n  // - Final path cells (visited) will be light\n  // - All other cells will be dark/black\n  \n  // Final update with complete walls\n  updateWalls(new Set(walls));\n  \n  // Signal that generation is complete and force immediate UI update\n  updateWalls(new Set(walls));\n  updateMazeGeneration(new Set(['generation_complete']));\n  \n  return {\n    walls: new Set(walls),\n    generationSteps,\n    visitedCells: visited.size\n  };\n};\n\nexport default generateMazeWithPrims;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}