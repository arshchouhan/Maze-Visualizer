{"ast":null,"code":"/**\n * Simple Prim's Algorithm for Maze Generation\n */\n\n// Helper function to add delay for animation\nconst sleep = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n/**\n * Generates a maze using Prim's algorithm with step-by-step animation\n * @param {number} gridSize - The size of the grid\n * @param {Function} updateWalls - Callback to update UI with current walls\n * @param {Function} updateMazeGeneration - Callback to update UI with maze generation cells\n * @param {number} animationSpeed - Speed of animation in milliseconds\n * @returns {Object} - Results including final walls set and generation stats\n */\nexport const generateMazeWithPrims = async (gridSize, updateWalls, updateMazeGeneration, animationSpeed = 150) => {\n  // Initialize: Start with empty grid, then add walls to create maze\n  const walls = new Set();\n  const visited = new Set();\n  const frontierCells = [];\n  const mazeGenerationCells = new Set();\n\n  // Step 1: Start from top-left corner (1,1 to leave border space)\n  const startRow = 1;\n  const startCol = 1;\n  const startCell = `${startRow}-${startCol}`;\n\n  // Step 2: Mark starting cell as visited (this will remain a passage)\n  visited.add(startCell);\n  mazeGenerationCells.add(startCell);\n\n  // Step 3: Add neighboring cells to frontier\n  const addNeighborsToFrontier = (row, col) => {\n    const neighbors = [[row - 2, col], [row + 2, col],\n    // Vertical neighbors (2 steps for proper maze)\n    [row, col - 2], [row, col + 2] // Horizontal neighbors (2 steps for proper maze)\n    ];\n    for (const [newRow, newCol] of neighbors) {\n      if (newRow > 0 && newRow < gridSize - 1 && newCol > 0 && newCol < gridSize - 1) {\n        const cellKey = `${newRow}-${newCol}`;\n        if (!visited.has(cellKey) && !frontierCells.some(([r, c]) => r === newRow && c === newCol)) {\n          frontierCells.push([newRow, newCol]);\n        }\n      }\n    }\n  };\n  addNeighborsToFrontier(startRow, startCol);\n  let generationSteps = 0;\n\n  // Update initial state\n  updateWalls(new Set(walls));\n  updateMazeGeneration(new Set(mazeGenerationCells));\n  await sleep(animationSpeed);\n\n  // Main Prim's algorithm loop\n  while (frontierCells.length > 0) {\n    // Pick a random frontier cell\n    const randomIndex = Math.floor(Math.random() * frontierCells.length);\n    const [cellRow, cellCol] = frontierCells.splice(randomIndex, 1)[0];\n    const cellKey = `${cellRow}-${cellCol}`;\n\n    // Find visited neighbors of this frontier cell\n    const visitedNeighbors = [];\n    const neighborDirections = [[cellRow - 2, cellCol], [cellRow + 2, cellCol], [cellRow, cellCol - 2], [cellRow, cellCol + 2]];\n    for (const [nRow, nCol] of neighborDirections) {\n      if (nRow >= 0 && nRow < gridSize && nCol >= 0 && nCol < gridSize) {\n        if (visited.has(`${nRow}-${nCol}`)) {\n          visitedNeighbors.push([nRow, nCol]);\n        }\n      }\n    }\n\n    // If this frontier cell has visited neighbors, connect it\n    if (visitedNeighbors.length > 0) {\n      // Mark this cell as visited (it becomes a passage)\n      visited.add(cellKey);\n      mazeGenerationCells.add(cellKey);\n\n      // Connect to a random visited neighbor by removing the wall between them\n      const [neighborRow, neighborCol] = visitedNeighbors[Math.floor(Math.random() * visitedNeighbors.length)];\n      const wallRow = (cellRow + neighborRow) / 2;\n      const wallCol = (cellCol + neighborCol) / 2;\n      const wallKey = `${wallRow}-${wallCol}`;\n\n      // The wall between them should also be a passage\n      visited.add(wallKey);\n      mazeGenerationCells.add(wallKey);\n\n      // Add new frontier cells\n      addNeighborsToFrontier(cellRow, cellCol);\n      generationSteps++;\n\n      // Update UI with animation\n      updateWalls(new Set(walls));\n      updateMazeGeneration(new Set(mazeGenerationCells));\n      await sleep(animationSpeed);\n    }\n  }\n\n  // Step 4: Create walls - everything NOT visited becomes a wall\n  for (let row = 0; row < gridSize; row++) {\n    for (let col = 0; col < gridSize; col++) {\n      const cellKey = `${row}-${col}`;\n      if (!visited.has(cellKey)) {\n        walls.add(cellKey);\n      }\n    }\n  }\n\n  // Final update with complete walls\n  updateWalls(new Set(walls));\n\n  // Clear maze generation cells after a delay\n  setTimeout(() => {\n    updateMazeGeneration(new Set());\n  }, 1500);\n  return {\n    walls: new Set(walls),\n    passages: visited,\n    generationSteps,\n    visitedCells: visited.size\n  };\n};\nexport default generateMazeWithPrims;","map":{"version":3,"names":["sleep","ms","Promise","resolve","setTimeout","generateMazeWithPrims","gridSize","updateWalls","updateMazeGeneration","animationSpeed","walls","Set","visited","frontierCells","mazeGenerationCells","startRow","startCol","startCell","add","addNeighborsToFrontier","row","col","neighbors","newRow","newCol","cellKey","has","some","r","c","push","generationSteps","length","randomIndex","Math","floor","random","cellRow","cellCol","splice","visitedNeighbors","neighborDirections","nRow","nCol","neighborRow","neighborCol","wallRow","wallCol","wallKey","passages","visitedCells","size"],"sources":["E:/maze_analyser/src/algorithms/primsAlgorithm.js"],"sourcesContent":["/**\n * Simple Prim's Algorithm for Maze Generation\n */\n\n// Helper function to add delay for animation\nconst sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));\n\n/**\n * Generates a maze using Prim's algorithm with step-by-step animation\n * @param {number} gridSize - The size of the grid\n * @param {Function} updateWalls - Callback to update UI with current walls\n * @param {Function} updateMazeGeneration - Callback to update UI with maze generation cells\n * @param {number} animationSpeed - Speed of animation in milliseconds\n * @returns {Object} - Results including final walls set and generation stats\n */\nexport const generateMazeWithPrims = async (\n  gridSize,\n  updateWalls,\n  updateMazeGeneration,\n  animationSpeed = 150\n) => {\n  // Initialize: Start with empty grid, then add walls to create maze\n  const walls = new Set();\n  const visited = new Set();\n  const frontierCells = [];\n  const mazeGenerationCells = new Set();\n  \n  // Step 1: Start from top-left corner (1,1 to leave border space)\n  const startRow = 1;\n  const startCol = 1;\n  const startCell = `${startRow}-${startCol}`;\n  \n  // Step 2: Mark starting cell as visited (this will remain a passage)\n  visited.add(startCell);\n  mazeGenerationCells.add(startCell);\n  \n  // Step 3: Add neighboring cells to frontier\n  const addNeighborsToFrontier = (row, col) => {\n    const neighbors = [\n      [row - 2, col], [row + 2, col], // Vertical neighbors (2 steps for proper maze)\n      [row, col - 2], [row, col + 2]  // Horizontal neighbors (2 steps for proper maze)\n    ];\n    \n    for (const [newRow, newCol] of neighbors) {\n      if (newRow > 0 && newRow < gridSize - 1 && newCol > 0 && newCol < gridSize - 1) {\n        const cellKey = `${newRow}-${newCol}`;\n        if (!visited.has(cellKey) && !frontierCells.some(([r, c]) => r === newRow && c === newCol)) {\n          frontierCells.push([newRow, newCol]);\n        }\n      }\n    }\n  };\n  \n  addNeighborsToFrontier(startRow, startCol);\n  \n  let generationSteps = 0;\n  \n  // Update initial state\n  updateWalls(new Set(walls));\n  updateMazeGeneration(new Set(mazeGenerationCells));\n  await sleep(animationSpeed);\n\n  // Main Prim's algorithm loop\n  while (frontierCells.length > 0) {\n    // Pick a random frontier cell\n    const randomIndex = Math.floor(Math.random() * frontierCells.length);\n    const [cellRow, cellCol] = frontierCells.splice(randomIndex, 1)[0];\n    const cellKey = `${cellRow}-${cellCol}`;\n    \n    // Find visited neighbors of this frontier cell\n    const visitedNeighbors = [];\n    const neighborDirections = [\n      [cellRow - 2, cellCol], [cellRow + 2, cellCol],\n      [cellRow, cellCol - 2], [cellRow, cellCol + 2]\n    ];\n    \n    for (const [nRow, nCol] of neighborDirections) {\n      if (nRow >= 0 && nRow < gridSize && nCol >= 0 && nCol < gridSize) {\n        if (visited.has(`${nRow}-${nCol}`)) {\n          visitedNeighbors.push([nRow, nCol]);\n        }\n      }\n    }\n    \n    // If this frontier cell has visited neighbors, connect it\n    if (visitedNeighbors.length > 0) {\n      // Mark this cell as visited (it becomes a passage)\n      visited.add(cellKey);\n      mazeGenerationCells.add(cellKey);\n      \n      // Connect to a random visited neighbor by removing the wall between them\n      const [neighborRow, neighborCol] = visitedNeighbors[Math.floor(Math.random() * visitedNeighbors.length)];\n      const wallRow = (cellRow + neighborRow) / 2;\n      const wallCol = (cellCol + neighborCol) / 2;\n      const wallKey = `${wallRow}-${wallCol}`;\n      \n      // The wall between them should also be a passage\n      visited.add(wallKey);\n      mazeGenerationCells.add(wallKey);\n      \n      // Add new frontier cells\n      addNeighborsToFrontier(cellRow, cellCol);\n      \n      generationSteps++;\n      \n      // Update UI with animation\n      updateWalls(new Set(walls));\n      updateMazeGeneration(new Set(mazeGenerationCells));\n      await sleep(animationSpeed);\n    }\n  }\n  \n  // Step 4: Create walls - everything NOT visited becomes a wall\n  for (let row = 0; row < gridSize; row++) {\n    for (let col = 0; col < gridSize; col++) {\n      const cellKey = `${row}-${col}`;\n      if (!visited.has(cellKey)) {\n        walls.add(cellKey);\n      }\n    }\n  }\n  \n  // Final update with complete walls\n  updateWalls(new Set(walls));\n  \n  // Clear maze generation cells after a delay\n  setTimeout(() => {\n    updateMazeGeneration(new Set());\n  }, 1500);\n  \n  return {\n    walls: new Set(walls),\n    passages: visited,\n    generationSteps,\n    visitedCells: visited.size\n  };\n};\n\nexport default generateMazeWithPrims;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}