{"ast":null,"code":"/**\n * Recursive Division Algorithm for Maze Generation\n * \n * This algorithm generates a maze by starting with an empty space and \n * recursively dividing it with walls, leaving passages through each wall.\n * \n * Data Structures Used:\n * - Set: For tracking walls and division cells\n * - Array: For managing division operations and animation steps\n * - Recursive function calls: For the division process\n */\n\n/**\n * Generates a maze using Recursive Division algorithm with systematic grid-like animation\n * @param {number} gridSize - The size of the grid (gridSize x gridSize)\n * @param {Function} updateWalls - Callback to update UI with current walls\n * @param {Function} updateMazeGeneration - Callback to update UI with maze generation cells\n * @param {number} animationSpeed - Speed of animation in milliseconds\n * @returns {Object} - Results including final walls set and generation stats\n */\nexport const generateMazeWithRecursiveDivision = async (gridSize, updateWalls, updateMazeGeneration, animationSpeed = 150) => {\n  const walls = new Set();\n  const mazeGenerationCells = new Set();\n  let generationSteps = 0;\n\n  // Initialize: Start with border walls only\n  for (let row = 0; row < gridSize; row++) {\n    for (let col = 0; col < gridSize; col++) {\n      // Only create border walls initially\n      if (row === 0 || row === gridSize - 1 || col === 0 || col === gridSize - 1) {\n        walls.add(`${row}-${col}`);\n      }\n    }\n  }\n\n  // Update initial state (empty interior with border walls)\n  updateWalls(new Set(walls));\n  updateMazeGeneration(new Set());\n  await sleep(animationSpeed);\n\n  // Create systematic grid-like divisions\n  await createSystematicDivisions(gridSize, walls, mazeGenerationCells, updateWalls, updateMazeGeneration, animationSpeed, () => {\n    generationSteps++;\n  });\n\n  // Clear maze generation cells after completion\n  setTimeout(() => {\n    updateMazeGeneration(new Set());\n  }, 1500);\n  return {\n    walls: new Set(walls),\n    generationSteps,\n    visitedCells: gridSize * gridSize - walls.size\n  };\n};\n\n/**\n * Recursively divide a rectangular area with walls\n * @param {number} x - Left boundary of the area\n * @param {number} y - Top boundary of the area  \n * @param {number} width - Width of the area\n * @param {number} height - Height of the area\n * @param {Set} walls - Current walls set\n * @param {Set} mazeGenerationCells - Cells being processed\n * @param {Function} updateWalls - Callback to update walls\n * @param {Function} updateMazeGeneration - Callback to update generation cells\n * @param {number} animationSpeed - Animation delay\n * @param {Function} incrementSteps - Callback to increment step counter\n */\nasync function recursiveDivide(x, y, width, height, walls, mazeGenerationCells, updateWalls, updateMazeGeneration, animationSpeed, incrementSteps) {\n  // Base case: area too small to divide\n  if (width < 2 || height < 2) {\n    return;\n  }\n\n  // Decide whether to divide horizontally or vertically\n  const horizontal = shouldDivideHorizontally(width, height);\n  if (horizontal) {\n    await divideHorizontally(x, y, width, height, walls, mazeGenerationCells, updateWalls, updateMazeGeneration, animationSpeed, incrementSteps);\n  } else {\n    await divideVertically(x, y, width, height, walls, mazeGenerationCells, updateWalls, updateMazeGeneration, animationSpeed, incrementSteps);\n  }\n}\n\n/**\n * Divide an area horizontally with a wall\n */\nasync function divideHorizontally(x, y, width, height, walls, mazeGenerationCells, updateWalls, updateMazeGeneration, animationSpeed, incrementSteps) {\n  // Choose a random row to place the wall (must be even for proper maze structure)\n  const wallY = y + 1 + Math.floor(Math.random() * (height - 1));\n\n  // Choose a random position for the passage (must be odd)\n  const passageX = x + Math.floor(Math.random() * width);\n\n  // Add horizontal wall with passage\n  const newWallCells = [];\n  for (let col = x; col < x + width; col++) {\n    if (col !== passageX) {\n      const cellKey = `${wallY}-${col}`;\n      walls.add(cellKey);\n      mazeGenerationCells.add(cellKey);\n      newWallCells.push(cellKey);\n    }\n  }\n\n  // Animate the wall creation\n  incrementSteps();\n  updateWalls(new Set(walls));\n  updateMazeGeneration(new Set(mazeGenerationCells));\n  await sleep(animationSpeed);\n\n  // Remove the wall cells from generation display after a short delay\n  setTimeout(() => {\n    newWallCells.forEach(cell => mazeGenerationCells.delete(cell));\n    updateMazeGeneration(new Set(mazeGenerationCells));\n  }, animationSpeed * 2);\n\n  // Recursively divide the two new areas\n  await recursiveDivide(x, y, width, wallY - y, walls, mazeGenerationCells, updateWalls, updateMazeGeneration, animationSpeed, incrementSteps);\n  await recursiveDivide(x, wallY + 1, width, height - (wallY - y + 1), walls, mazeGenerationCells, updateWalls, updateMazeGeneration, animationSpeed, incrementSteps);\n}\n\n/**\n * Divide an area vertically with a wall\n */\nasync function divideVertically(x, y, width, height, walls, mazeGenerationCells, updateWalls, updateMazeGeneration, animationSpeed, incrementSteps) {\n  // Choose a random column to place the wall\n  const wallX = x + 1 + Math.floor(Math.random() * (width - 1));\n\n  // Choose a random position for the passage\n  const passageY = y + Math.floor(Math.random() * height);\n\n  // Add vertical wall with passage\n  const newWallCells = [];\n  for (let row = y; row < y + height; row++) {\n    if (row !== passageY) {\n      const cellKey = `${row}-${wallX}`;\n      walls.add(cellKey);\n      mazeGenerationCells.add(cellKey);\n      newWallCells.push(cellKey);\n    }\n  }\n\n  // Animate the wall creation\n  incrementSteps();\n  updateWalls(new Set(walls));\n  updateMazeGeneration(new Set(mazeGenerationCells));\n  await sleep(animationSpeed);\n\n  // Remove the wall cells from generation display after a short delay\n  setTimeout(() => {\n    newWallCells.forEach(cell => mazeGenerationCells.delete(cell));\n    updateMazeGeneration(new Set(mazeGenerationCells));\n  }, animationSpeed * 2);\n\n  // Recursively divide the two new areas\n  await recursiveDivide(x, y, wallX - x, height, walls, mazeGenerationCells, updateWalls, updateMazeGeneration, animationSpeed, incrementSteps);\n  await recursiveDivide(wallX + 1, y, width - (wallX - x + 1), height, walls, mazeGenerationCells, updateWalls, updateMazeGeneration, animationSpeed, incrementSteps);\n}\n\n/**\n * Determine whether to divide horizontally or vertically\n * Generally prefer to divide the longer dimension\n */\nfunction shouldDivideHorizontally(width, height) {\n  if (width < height) {\n    return true; // Divide horizontally if height is greater\n  } else if (height < width) {\n    return false; // Divide vertically if width is greater\n  } else {\n    return Math.random() < 0.5; // Random choice if equal\n  }\n}\n\n/**\n * Sleep function for animation delays\n */\nfunction sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n/**\n * Generate maze steps for step-by-step visualization (simplified version)\n */\nexport const getRecursiveDivisionSteps = gridSize => {\n  const steps = [];\n  const walls = new Set();\n\n  // Initialize with border walls\n  for (let row = 0; row < gridSize; row++) {\n    for (let col = 0; col < gridSize; col++) {\n      if (row === 0 || row === gridSize - 1 || col === 0 || col === gridSize - 1) {\n        walls.add(`${row}-${col}`);\n      }\n    }\n  }\n  steps.push({\n    walls: new Set(walls),\n    action: 'start',\n    description: 'Starting with border walls only'\n  });\n\n  // This would contain the recursive division steps\n  // For now, return the initial step\n  return steps;\n};\nexport default generateMazeWithRecursiveDivision;","map":{"version":3,"names":["generateMazeWithRecursiveDivision","gridSize","updateWalls","updateMazeGeneration","animationSpeed","walls","Set","mazeGenerationCells","generationSteps","row","col","add","sleep","createSystematicDivisions","setTimeout","visitedCells","size","recursiveDivide","x","y","width","height","incrementSteps","horizontal","shouldDivideHorizontally","divideHorizontally","divideVertically","wallY","Math","floor","random","passageX","newWallCells","cellKey","push","forEach","cell","delete","wallX","passageY","ms","Promise","resolve","getRecursiveDivisionSteps","steps","action","description"],"sources":["E:/maze_analyser/src/algorithms/recursiveDivision.js"],"sourcesContent":["/**\n * Recursive Division Algorithm for Maze Generation\n * \n * This algorithm generates a maze by starting with an empty space and \n * recursively dividing it with walls, leaving passages through each wall.\n * \n * Data Structures Used:\n * - Set: For tracking walls and division cells\n * - Array: For managing division operations and animation steps\n * - Recursive function calls: For the division process\n */\n\n/**\n * Generates a maze using Recursive Division algorithm with systematic grid-like animation\n * @param {number} gridSize - The size of the grid (gridSize x gridSize)\n * @param {Function} updateWalls - Callback to update UI with current walls\n * @param {Function} updateMazeGeneration - Callback to update UI with maze generation cells\n * @param {number} animationSpeed - Speed of animation in milliseconds\n * @returns {Object} - Results including final walls set and generation stats\n */\nexport const generateMazeWithRecursiveDivision = async (\n  gridSize,\n  updateWalls,\n  updateMazeGeneration,\n  animationSpeed = 150\n) => {\n  const walls = new Set();\n  const mazeGenerationCells = new Set();\n  let generationSteps = 0;\n  \n  // Initialize: Start with border walls only\n  for (let row = 0; row < gridSize; row++) {\n    for (let col = 0; col < gridSize; col++) {\n      // Only create border walls initially\n      if (row === 0 || row === gridSize - 1 || col === 0 || col === gridSize - 1) {\n        walls.add(`${row}-${col}`);\n      }\n    }\n  }\n  \n  // Update initial state (empty interior with border walls)\n  updateWalls(new Set(walls));\n  updateMazeGeneration(new Set());\n  await sleep(animationSpeed);\n  \n  // Create systematic grid-like divisions\n  await createSystematicDivisions(\n    gridSize,\n    walls,\n    mazeGenerationCells,\n    updateWalls,\n    updateMazeGeneration,\n    animationSpeed,\n    () => { generationSteps++; }\n  );\n  \n  // Clear maze generation cells after completion\n  setTimeout(() => {\n    updateMazeGeneration(new Set());\n  }, 1500);\n  \n  return {\n    walls: new Set(walls),\n    generationSteps,\n    visitedCells: gridSize * gridSize - walls.size\n  };\n};\n\n/**\n * Recursively divide a rectangular area with walls\n * @param {number} x - Left boundary of the area\n * @param {number} y - Top boundary of the area  \n * @param {number} width - Width of the area\n * @param {number} height - Height of the area\n * @param {Set} walls - Current walls set\n * @param {Set} mazeGenerationCells - Cells being processed\n * @param {Function} updateWalls - Callback to update walls\n * @param {Function} updateMazeGeneration - Callback to update generation cells\n * @param {number} animationSpeed - Animation delay\n * @param {Function} incrementSteps - Callback to increment step counter\n */\nasync function recursiveDivide(\n  x, y, width, height, \n  walls, mazeGenerationCells,\n  updateWalls, updateMazeGeneration, \n  animationSpeed, incrementSteps\n) {\n  // Base case: area too small to divide\n  if (width < 2 || height < 2) {\n    return;\n  }\n  \n  // Decide whether to divide horizontally or vertically\n  const horizontal = shouldDivideHorizontally(width, height);\n  \n  if (horizontal) {\n    await divideHorizontally(\n      x, y, width, height,\n      walls, mazeGenerationCells,\n      updateWalls, updateMazeGeneration,\n      animationSpeed, incrementSteps\n    );\n  } else {\n    await divideVertically(\n      x, y, width, height,\n      walls, mazeGenerationCells,\n      updateWalls, updateMazeGeneration,\n      animationSpeed, incrementSteps\n    );\n  }\n}\n\n/**\n * Divide an area horizontally with a wall\n */\nasync function divideHorizontally(\n  x, y, width, height,\n  walls, mazeGenerationCells,\n  updateWalls, updateMazeGeneration,\n  animationSpeed, incrementSteps\n) {\n  // Choose a random row to place the wall (must be even for proper maze structure)\n  const wallY = y + 1 + Math.floor(Math.random() * (height - 1));\n  \n  // Choose a random position for the passage (must be odd)\n  const passageX = x + Math.floor(Math.random() * width);\n  \n  // Add horizontal wall with passage\n  const newWallCells = [];\n  for (let col = x; col < x + width; col++) {\n    if (col !== passageX) {\n      const cellKey = `${wallY}-${col}`;\n      walls.add(cellKey);\n      mazeGenerationCells.add(cellKey);\n      newWallCells.push(cellKey);\n    }\n  }\n  \n  // Animate the wall creation\n  incrementSteps();\n  updateWalls(new Set(walls));\n  updateMazeGeneration(new Set(mazeGenerationCells));\n  await sleep(animationSpeed);\n  \n  // Remove the wall cells from generation display after a short delay\n  setTimeout(() => {\n    newWallCells.forEach(cell => mazeGenerationCells.delete(cell));\n    updateMazeGeneration(new Set(mazeGenerationCells));\n  }, animationSpeed * 2);\n  \n  // Recursively divide the two new areas\n  await recursiveDivide(\n    x, y, width, wallY - y,\n    walls, mazeGenerationCells,\n    updateWalls, updateMazeGeneration,\n    animationSpeed, incrementSteps\n  );\n  \n  await recursiveDivide(\n    x, wallY + 1, width, height - (wallY - y + 1),\n    walls, mazeGenerationCells,\n    updateWalls, updateMazeGeneration,\n    animationSpeed, incrementSteps\n  );\n}\n\n/**\n * Divide an area vertically with a wall\n */\nasync function divideVertically(\n  x, y, width, height,\n  walls, mazeGenerationCells,\n  updateWalls, updateMazeGeneration,\n  animationSpeed, incrementSteps\n) {\n  // Choose a random column to place the wall\n  const wallX = x + 1 + Math.floor(Math.random() * (width - 1));\n  \n  // Choose a random position for the passage\n  const passageY = y + Math.floor(Math.random() * height);\n  \n  // Add vertical wall with passage\n  const newWallCells = [];\n  for (let row = y; row < y + height; row++) {\n    if (row !== passageY) {\n      const cellKey = `${row}-${wallX}`;\n      walls.add(cellKey);\n      mazeGenerationCells.add(cellKey);\n      newWallCells.push(cellKey);\n    }\n  }\n  \n  // Animate the wall creation\n  incrementSteps();\n  updateWalls(new Set(walls));\n  updateMazeGeneration(new Set(mazeGenerationCells));\n  await sleep(animationSpeed);\n  \n  // Remove the wall cells from generation display after a short delay\n  setTimeout(() => {\n    newWallCells.forEach(cell => mazeGenerationCells.delete(cell));\n    updateMazeGeneration(new Set(mazeGenerationCells));\n  }, animationSpeed * 2);\n  \n  // Recursively divide the two new areas\n  await recursiveDivide(\n    x, y, wallX - x, height,\n    walls, mazeGenerationCells,\n    updateWalls, updateMazeGeneration,\n    animationSpeed, incrementSteps\n  );\n  \n  await recursiveDivide(\n    wallX + 1, y, width - (wallX - x + 1), height,\n    walls, mazeGenerationCells,\n    updateWalls, updateMazeGeneration,\n    animationSpeed, incrementSteps\n  );\n}\n\n/**\n * Determine whether to divide horizontally or vertically\n * Generally prefer to divide the longer dimension\n */\nfunction shouldDivideHorizontally(width, height) {\n  if (width < height) {\n    return true; // Divide horizontally if height is greater\n  } else if (height < width) {\n    return false; // Divide vertically if width is greater\n  } else {\n    return Math.random() < 0.5; // Random choice if equal\n  }\n}\n\n/**\n * Sleep function for animation delays\n */\nfunction sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n/**\n * Generate maze steps for step-by-step visualization (simplified version)\n */\nexport const getRecursiveDivisionSteps = (gridSize) => {\n  const steps = [];\n  const walls = new Set();\n  \n  // Initialize with border walls\n  for (let row = 0; row < gridSize; row++) {\n    for (let col = 0; col < gridSize; col++) {\n      if (row === 0 || row === gridSize - 1 || col === 0 || col === gridSize - 1) {\n        walls.add(`${row}-${col}`);\n      }\n    }\n  }\n  \n  steps.push({\n    walls: new Set(walls),\n    action: 'start',\n    description: 'Starting with border walls only'\n  });\n  \n  // This would contain the recursive division steps\n  // For now, return the initial step\n  return steps;\n};\n\nexport default generateMazeWithRecursiveDivision;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}