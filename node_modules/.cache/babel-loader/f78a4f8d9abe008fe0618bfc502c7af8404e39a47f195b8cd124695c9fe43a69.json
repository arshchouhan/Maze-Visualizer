{"ast":null,"code":"/**\n * Breadth-First Search algorithm for maze pathfinding\n * \n * This algorithm explores all nodes at the present depth before moving on to nodes at the next depth level.\n * It guarantees the shortest path in an unweighted graph.\n * \n * @param {Object} grid - The grid representation containing rows and columns\n * @param {Object} startPos - The starting position with row and col properties\n * @param {Object} targetPos - The target position with row and col properties\n * @param {Set} walls - Set of wall positions in format \"row-col\"\n * @param {number} rows - Total number of rows in the grid\n * @param {number} cols - Total number of columns in the grid\n * @returns {Object} - Result containing path, visited nodes, and other metadata\n */\nexport const breadthFirstSearch = (grid, startPos, targetPos, walls, rows, cols) => {\n  // Track all visited cells to avoid revisiting\n  const visited = new Set();\n\n  // Queue for BFS traversal\n  const queue = [];\n\n  // Track the path to reconstruct later\n  const cameFrom = new Map();\n\n  // Store all visited nodes in order for visualization\n  const visitedNodesInOrder = [];\n\n  // Initialize with the start position\n  queue.push(startPos);\n  visited.add(`${startPos.row}-${startPos.col}`);\n\n  // The four possible directions to move: up, right, down, left\n  const directions = [{\n    row: -1,\n    col: 0\n  },\n  // up\n  {\n    row: 0,\n    col: 1\n  },\n  // right\n  {\n    row: 1,\n    col: 0\n  },\n  // down\n  {\n    row: 0,\n    col: -1\n  } // left\n  ];\n\n  // Perform BFS\n  while (queue.length > 0) {\n    // Get the next cell to visit\n    const current = queue.shift();\n\n    // Add to visited nodes for visualization\n    visitedNodesInOrder.push(current);\n\n    // Check if we reached the target\n    if (current.row === targetPos.row && current.col === targetPos.col) {\n      // Found the target, reconstruct and return the path\n      return {\n        success: true,\n        path: reconstructPath(cameFrom, targetPos),\n        visited: visitedNodesInOrder,\n        message: \"Path found successfully!\"\n      };\n    }\n\n    // Explore all four directions\n    for (const direction of directions) {\n      const newRow = current.row + direction.row;\n      const newCol = current.col + direction.col;\n\n      // Check if the new position is valid\n      if (newRow >= 0 && newRow < rows &&\n      // Within grid rows\n      newCol >= 0 && newCol < cols &&\n      // Within grid columns\n      !visited.has(`${newRow}-${newCol}`) &&\n      // Not visited before\n      !walls.has(`${newRow}-${newCol}`) // Not a wall\n      ) {\n        const neighbor = {\n          row: newRow,\n          col: newCol\n        };\n\n        // Mark as visited\n        visited.add(`${newRow}-${newCol}`);\n\n        // Add to queue for exploration\n        queue.push(neighbor);\n\n        // Remember where we came from to reconstruct path\n        cameFrom.set(`${newRow}-${newCol}`, current);\n      }\n    }\n  }\n\n  // If we get here, no path was found\n  return {\n    success: false,\n    visited: visitedNodesInOrder,\n    path: [],\n    message: \"No path found to the target!\"\n  };\n};\n\n/**\n * Reconstructs the path from start to target using the cameFrom map\n * \n * @param {Map} cameFrom - Map tracking which cell led to which\n * @param {Object} targetPos - The target position to backtrack from\n * @returns {Array} - Array of positions forming the shortest path\n */\nconst reconstructPath = (cameFrom, targetPos) => {\n  const path = [];\n  let current = targetPos;\n\n  // Start from target and work backwards\n  while (cameFrom.has(`${current.row}-${current.col}`)) {\n    path.unshift(current); // Add to front of array\n    current = cameFrom.get(`${current.row}-${current.col}`);\n  }\n\n  // Add the start position\n  path.unshift(current);\n  return path;\n};\n\n/**\n * Returns the neighbors of a cell that are valid moves\n * \n * @param {Object} cell - The cell to find neighbors for\n * @param {Set} walls - Set of wall positions\n * @param {number} rows - Total number of rows\n * @param {number} cols - Total number of columns\n * @returns {Array} - Array of valid neighbor cells\n */\nexport const getNeighbors = (cell, walls, rows, cols) => {\n  const {\n    row,\n    col\n  } = cell;\n  const neighbors = [];\n\n  // Check all four directions\n  const directions = [{\n    row: -1,\n    col: 0\n  },\n  // up\n  {\n    row: 0,\n    col: 1\n  },\n  // right\n  {\n    row: 1,\n    col: 0\n  },\n  // down\n  {\n    row: 0,\n    col: -1\n  } // left\n  ];\n  for (const direction of directions) {\n    const newRow = row + direction.row;\n    const newCol = col + direction.col;\n\n    // Make sure neighbor is within grid bounds and not a wall\n    if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols && !walls.has(`${newRow}-${newCol}`)) {\n      neighbors.push({\n        row: newRow,\n        col: newCol\n      });\n    }\n  }\n  return neighbors;\n};","map":{"version":3,"names":["breadthFirstSearch","grid","startPos","targetPos","walls","rows","cols","visited","Set","queue","cameFrom","Map","visitedNodesInOrder","push","add","row","col","directions","length","current","shift","success","path","reconstructPath","message","direction","newRow","newCol","has","neighbor","set","unshift","get","getNeighbors","cell","neighbors"],"sources":["E:/maze_analyser/src/algorithms/breadthFirstSearch.js"],"sourcesContent":["/**\n * Breadth-First Search algorithm for maze pathfinding\n * \n * This algorithm explores all nodes at the present depth before moving on to nodes at the next depth level.\n * It guarantees the shortest path in an unweighted graph.\n * \n * @param {Object} grid - The grid representation containing rows and columns\n * @param {Object} startPos - The starting position with row and col properties\n * @param {Object} targetPos - The target position with row and col properties\n * @param {Set} walls - Set of wall positions in format \"row-col\"\n * @param {number} rows - Total number of rows in the grid\n * @param {number} cols - Total number of columns in the grid\n * @returns {Object} - Result containing path, visited nodes, and other metadata\n */\nexport const breadthFirstSearch = (grid, startPos, targetPos, walls, rows, cols) => {\n  // Track all visited cells to avoid revisiting\n  const visited = new Set();\n  \n  // Queue for BFS traversal\n  const queue = [];\n  \n  // Track the path to reconstruct later\n  const cameFrom = new Map();\n  \n  // Store all visited nodes in order for visualization\n  const visitedNodesInOrder = [];\n  \n  // Initialize with the start position\n  queue.push(startPos);\n  visited.add(`${startPos.row}-${startPos.col}`);\n  \n  // The four possible directions to move: up, right, down, left\n  const directions = [\n    { row: -1, col: 0 },  // up\n    { row: 0, col: 1 },   // right\n    { row: 1, col: 0 },   // down\n    { row: 0, col: -1 }   // left\n  ];\n  \n  // Perform BFS\n  while (queue.length > 0) {\n    // Get the next cell to visit\n    const current = queue.shift();\n    \n    // Add to visited nodes for visualization\n    visitedNodesInOrder.push(current);\n    \n    // Check if we reached the target\n    if (current.row === targetPos.row && current.col === targetPos.col) {\n      // Found the target, reconstruct and return the path\n      return {\n        success: true,\n        path: reconstructPath(cameFrom, targetPos),\n        visited: visitedNodesInOrder,\n        message: \"Path found successfully!\"\n      };\n    }\n    \n    // Explore all four directions\n    for (const direction of directions) {\n      const newRow = current.row + direction.row;\n      const newCol = current.col + direction.col;\n      \n      // Check if the new position is valid\n      if (\n        newRow >= 0 && newRow < rows &&  // Within grid rows\n        newCol >= 0 && newCol < cols &&  // Within grid columns\n        !visited.has(`${newRow}-${newCol}`) &&  // Not visited before\n        !walls.has(`${newRow}-${newCol}`)       // Not a wall\n      ) {\n        const neighbor = { row: newRow, col: newCol };\n        \n        // Mark as visited\n        visited.add(`${newRow}-${newCol}`);\n        \n        // Add to queue for exploration\n        queue.push(neighbor);\n        \n        // Remember where we came from to reconstruct path\n        cameFrom.set(`${newRow}-${newCol}`, current);\n      }\n    }\n  }\n  \n  // If we get here, no path was found\n  return {\n    success: false,\n    visited: visitedNodesInOrder,\n    path: [],\n    message: \"No path found to the target!\"\n  };\n};\n\n/**\n * Reconstructs the path from start to target using the cameFrom map\n * \n * @param {Map} cameFrom - Map tracking which cell led to which\n * @param {Object} targetPos - The target position to backtrack from\n * @returns {Array} - Array of positions forming the shortest path\n */\nconst reconstructPath = (cameFrom, targetPos) => {\n  const path = [];\n  let current = targetPos;\n  \n  // Start from target and work backwards\n  while (cameFrom.has(`${current.row}-${current.col}`)) {\n    path.unshift(current);  // Add to front of array\n    current = cameFrom.get(`${current.row}-${current.col}`);\n  }\n  \n  // Add the start position\n  path.unshift(current);\n  \n  return path;\n};\n\n/**\n * Returns the neighbors of a cell that are valid moves\n * \n * @param {Object} cell - The cell to find neighbors for\n * @param {Set} walls - Set of wall positions\n * @param {number} rows - Total number of rows\n * @param {number} cols - Total number of columns\n * @returns {Array} - Array of valid neighbor cells\n */\nexport const getNeighbors = (cell, walls, rows, cols) => {\n  const { row, col } = cell;\n  const neighbors = [];\n  \n  // Check all four directions\n  const directions = [\n    { row: -1, col: 0 },  // up\n    { row: 0, col: 1 },   // right\n    { row: 1, col: 0 },   // down\n    { row: 0, col: -1 }   // left\n  ];\n  \n  for (const direction of directions) {\n    const newRow = row + direction.row;\n    const newCol = col + direction.col;\n    \n    // Make sure neighbor is within grid bounds and not a wall\n    if (\n      newRow >= 0 && newRow < rows &&\n      newCol >= 0 && newCol < cols &&\n      !walls.has(`${newRow}-${newCol}`)\n    ) {\n      neighbors.push({ row: newRow, col: newCol });\n    }\n  }\n  \n  return neighbors;\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMA,kBAAkB,GAAGA,CAACC,IAAI,EAAEC,QAAQ,EAAEC,SAAS,EAAEC,KAAK,EAAEC,IAAI,EAAEC,IAAI,KAAK;EAClF;EACA,MAAMC,OAAO,GAAG,IAAIC,GAAG,CAAC,CAAC;;EAEzB;EACA,MAAMC,KAAK,GAAG,EAAE;;EAEhB;EACA,MAAMC,QAAQ,GAAG,IAAIC,GAAG,CAAC,CAAC;;EAE1B;EACA,MAAMC,mBAAmB,GAAG,EAAE;;EAE9B;EACAH,KAAK,CAACI,IAAI,CAACX,QAAQ,CAAC;EACpBK,OAAO,CAACO,GAAG,CAAC,GAAGZ,QAAQ,CAACa,GAAG,IAAIb,QAAQ,CAACc,GAAG,EAAE,CAAC;;EAE9C;EACA,MAAMC,UAAU,GAAG,CACjB;IAAEF,GAAG,EAAE,CAAC,CAAC;IAAEC,GAAG,EAAE;EAAE,CAAC;EAAG;EACtB;IAAED,GAAG,EAAE,CAAC;IAAEC,GAAG,EAAE;EAAE,CAAC;EAAI;EACtB;IAAED,GAAG,EAAE,CAAC;IAAEC,GAAG,EAAE;EAAE,CAAC;EAAI;EACtB;IAAED,GAAG,EAAE,CAAC;IAAEC,GAAG,EAAE,CAAC;EAAE,CAAC,CAAG;EAAA,CACvB;;EAED;EACA,OAAOP,KAAK,CAACS,MAAM,GAAG,CAAC,EAAE;IACvB;IACA,MAAMC,OAAO,GAAGV,KAAK,CAACW,KAAK,CAAC,CAAC;;IAE7B;IACAR,mBAAmB,CAACC,IAAI,CAACM,OAAO,CAAC;;IAEjC;IACA,IAAIA,OAAO,CAACJ,GAAG,KAAKZ,SAAS,CAACY,GAAG,IAAII,OAAO,CAACH,GAAG,KAAKb,SAAS,CAACa,GAAG,EAAE;MAClE;MACA,OAAO;QACLK,OAAO,EAAE,IAAI;QACbC,IAAI,EAAEC,eAAe,CAACb,QAAQ,EAAEP,SAAS,CAAC;QAC1CI,OAAO,EAAEK,mBAAmB;QAC5BY,OAAO,EAAE;MACX,CAAC;IACH;;IAEA;IACA,KAAK,MAAMC,SAAS,IAAIR,UAAU,EAAE;MAClC,MAAMS,MAAM,GAAGP,OAAO,CAACJ,GAAG,GAAGU,SAAS,CAACV,GAAG;MAC1C,MAAMY,MAAM,GAAGR,OAAO,CAACH,GAAG,GAAGS,SAAS,CAACT,GAAG;;MAE1C;MACA,IACEU,MAAM,IAAI,CAAC,IAAIA,MAAM,GAAGrB,IAAI;MAAK;MACjCsB,MAAM,IAAI,CAAC,IAAIA,MAAM,GAAGrB,IAAI;MAAK;MACjC,CAACC,OAAO,CAACqB,GAAG,CAAC,GAAGF,MAAM,IAAIC,MAAM,EAAE,CAAC;MAAK;MACxC,CAACvB,KAAK,CAACwB,GAAG,CAAC,GAAGF,MAAM,IAAIC,MAAM,EAAE,CAAC,CAAO;MAAA,EACxC;QACA,MAAME,QAAQ,GAAG;UAAEd,GAAG,EAAEW,MAAM;UAAEV,GAAG,EAAEW;QAAO,CAAC;;QAE7C;QACApB,OAAO,CAACO,GAAG,CAAC,GAAGY,MAAM,IAAIC,MAAM,EAAE,CAAC;;QAElC;QACAlB,KAAK,CAACI,IAAI,CAACgB,QAAQ,CAAC;;QAEpB;QACAnB,QAAQ,CAACoB,GAAG,CAAC,GAAGJ,MAAM,IAAIC,MAAM,EAAE,EAAER,OAAO,CAAC;MAC9C;IACF;EACF;;EAEA;EACA,OAAO;IACLE,OAAO,EAAE,KAAK;IACdd,OAAO,EAAEK,mBAAmB;IAC5BU,IAAI,EAAE,EAAE;IACRE,OAAO,EAAE;EACX,CAAC;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMD,eAAe,GAAGA,CAACb,QAAQ,EAAEP,SAAS,KAAK;EAC/C,MAAMmB,IAAI,GAAG,EAAE;EACf,IAAIH,OAAO,GAAGhB,SAAS;;EAEvB;EACA,OAAOO,QAAQ,CAACkB,GAAG,CAAC,GAAGT,OAAO,CAACJ,GAAG,IAAII,OAAO,CAACH,GAAG,EAAE,CAAC,EAAE;IACpDM,IAAI,CAACS,OAAO,CAACZ,OAAO,CAAC,CAAC,CAAE;IACxBA,OAAO,GAAGT,QAAQ,CAACsB,GAAG,CAAC,GAAGb,OAAO,CAACJ,GAAG,IAAII,OAAO,CAACH,GAAG,EAAE,CAAC;EACzD;;EAEA;EACAM,IAAI,CAACS,OAAO,CAACZ,OAAO,CAAC;EAErB,OAAOG,IAAI;AACb,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMW,YAAY,GAAGA,CAACC,IAAI,EAAE9B,KAAK,EAAEC,IAAI,EAAEC,IAAI,KAAK;EACvD,MAAM;IAAES,GAAG;IAAEC;EAAI,CAAC,GAAGkB,IAAI;EACzB,MAAMC,SAAS,GAAG,EAAE;;EAEpB;EACA,MAAMlB,UAAU,GAAG,CACjB;IAAEF,GAAG,EAAE,CAAC,CAAC;IAAEC,GAAG,EAAE;EAAE,CAAC;EAAG;EACtB;IAAED,GAAG,EAAE,CAAC;IAAEC,GAAG,EAAE;EAAE,CAAC;EAAI;EACtB;IAAED,GAAG,EAAE,CAAC;IAAEC,GAAG,EAAE;EAAE,CAAC;EAAI;EACtB;IAAED,GAAG,EAAE,CAAC;IAAEC,GAAG,EAAE,CAAC;EAAE,CAAC,CAAG;EAAA,CACvB;EAED,KAAK,MAAMS,SAAS,IAAIR,UAAU,EAAE;IAClC,MAAMS,MAAM,GAAGX,GAAG,GAAGU,SAAS,CAACV,GAAG;IAClC,MAAMY,MAAM,GAAGX,GAAG,GAAGS,SAAS,CAACT,GAAG;;IAElC;IACA,IACEU,MAAM,IAAI,CAAC,IAAIA,MAAM,GAAGrB,IAAI,IAC5BsB,MAAM,IAAI,CAAC,IAAIA,MAAM,GAAGrB,IAAI,IAC5B,CAACF,KAAK,CAACwB,GAAG,CAAC,GAAGF,MAAM,IAAIC,MAAM,EAAE,CAAC,EACjC;MACAQ,SAAS,CAACtB,IAAI,CAAC;QAAEE,GAAG,EAAEW,MAAM;QAAEV,GAAG,EAAEW;MAAO,CAAC,CAAC;IAC9C;EACF;EAEA,OAAOQ,SAAS;AAClB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}