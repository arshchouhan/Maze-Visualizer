{"ast":null,"code":"/**\n * Recursive Division Algorithm for Maze Generation\n * \n * This algorithm generates a maze by starting with an empty space and \n * recursively dividing it with walls, leaving passages through each wall.\n * \n * Data Structures Used:\n * - Set: For tracking walls and division cells\n * - Array: For managing division operations and animation steps\n * - Recursive function calls: For the division process\n */\n\n/**\n * Generates a maze using Recursive Division algorithm with systematic grid-like animation\n * @param {number} gridSize - The size of the grid (gridSize x gridSize)\n * @param {Function} updateWalls - Callback to update UI with current walls\n * @param {Function} updateMazeGeneration - Callback to update UI with maze generation cells\n * @param {number} animationSpeed - Speed of animation in milliseconds\n * @param {Object} startPos - Starting position {row, col}\n * @param {Object} targetPos - Target position {row, col}\n * @returns {Object} - Results including final walls set and generation stats\n */\nexport const generateMazeWithRecursiveDivision = async (gridSize, updateWalls, updateMazeGeneration, animationSpeed = 120, startPos = {\n  row: 1,\n  col: 1\n}, targetPos = {\n  row: gridSize - 2,\n  col: gridSize - 2\n}) => {\n  const walls = new Set();\n  const mazeGenerationCells = new Set();\n  let generationSteps = 0;\n\n  // Initialize: Start with border walls only\n  for (let row = 0; row < gridSize; row++) {\n    for (let col = 0; col < gridSize; col++) {\n      // Only create border walls initially\n      if (row === 0 || row === gridSize - 1 || col === 0 || col === gridSize - 1) {\n        walls.add(`${row}-${col}`);\n      }\n    }\n  }\n\n  // Update initial state (empty interior with border walls)\n  updateWalls(new Set(walls));\n  updateMazeGeneration(new Set());\n  await sleep(animationSpeed);\n\n  // Start classic recursive division on the entire interior space\n  await recursiveDivide(1, 1,\n  // top-left of interior\n  gridSize - 2, gridSize - 2,\n  // width and height of interior\n  true,\n  // start with horizontal division\n  walls, mazeGenerationCells, updateWalls, updateMazeGeneration, animationSpeed, () => {\n    generationSteps++;\n  }, startPos, targetPos);\n\n  // Clear maze generation cells after completion\n  setTimeout(() => {\n    updateMazeGeneration(new Set());\n  }, 1500);\n  return {\n    walls: new Set(walls),\n    generationSteps,\n    visitedCells: gridSize * gridSize - walls.size\n  };\n};\n\n/**\n * Classic Recursive Division Algorithm\n * Recursively divides areas with alternating horizontal and vertical walls\n * @param {number} x - Left boundary of the area\n * @param {number} y - Top boundary of the area\n * @param {number} width - Width of the area\n * @param {number} height - Height of the area\n * @param {boolean} horizontal - Whether to divide horizontally (true) or vertically (false)\n * @param {Set} walls - Current walls set\n * @param {Set} mazeGenerationCells - Cells being processed\n * @param {Function} updateWalls - Callback to update walls\n * @param {Function} updateMazeGeneration - Callback to update generation cells\n * @param {number} animationSpeed - Animation delay\n * @param {Function} incrementSteps - Callback to increment step counter\n * @param {Object} startPos - Starting position {row, col}\n * @param {Object} targetPos - Target position {row, col}\n */\nasync function recursiveDivide(x, y, width, height, horizontal, walls, mazeGenerationCells, updateWalls, updateMazeGeneration, animationSpeed, incrementSteps, startPos, targetPos) {\n  // Base case: area too small to divide\n  if (width < 2 || height < 2) {\n    return;\n  }\n  if (horizontal) {\n    // Divide horizontally\n    if (height < 3) return; // Need at least 3 cells to divide horizontally\n\n    // Choose a random row to place the wall (avoid edges)\n    const wallY = y + 1 + Math.floor(Math.random() * (height - 2));\n\n    // Choose a random position for the passage\n    const passageX = x + Math.floor(Math.random() * width);\n\n    // Create horizontal wall with passage\n    await createHorizontalWall(x, wallY, width, passageX, walls, mazeGenerationCells, updateWalls, updateMazeGeneration, animationSpeed, incrementSteps);\n\n    // Recursively divide the two new areas (switch to vertical)\n    await recursiveDivide(x, y, width, wallY - y, false,\n    // top area, switch to vertical\n    walls, mazeGenerationCells, updateWalls, updateMazeGeneration, animationSpeed, incrementSteps, startPos, targetPos);\n    await recursiveDivide(x, wallY + 1, width, height - (wallY - y + 1), false,\n    // bottom area, switch to vertical\n    walls, mazeGenerationCells, updateWalls, updateMazeGeneration, animationSpeed, incrementSteps, startPos, targetPos);\n  } else {\n    // Divide vertically\n    if (width < 3) return; // Need at least 3 cells to divide vertically\n\n    // Choose a random column to place the wall (avoid edges)\n    const wallX = x + 1 + Math.floor(Math.random() * (width - 2));\n\n    // Choose a random position for the passage\n    const passageY = y + Math.floor(Math.random() * height);\n\n    // Create vertical wall with passage\n    await createVerticalWall(wallX, y, height, passageY, walls, mazeGenerationCells, updateWalls, updateMazeGeneration, animationSpeed, incrementSteps);\n\n    // Recursively divide the two new areas (switch to horizontal)\n    await recursiveDivide(x, y, wallX - x, height, true,\n    // left area, switch to horizontal\n    walls, mazeGenerationCells, updateWalls, updateMazeGeneration, animationSpeed, incrementSteps, startPos, targetPos);\n    await recursiveDivide(wallX + 1, y, width - (wallX - x + 1), height, true,\n    // right area, switch to horizontal\n    walls, mazeGenerationCells, updateWalls, updateMazeGeneration, animationSpeed, incrementSteps, startPos, targetPos);\n  }\n}\n\n/**\n * Create a vertical wall with a passage\n */\nasync function createVerticalWall(wallCol, startRow, height, passageRow, walls, mazeGenerationCells, updateWalls, updateMazeGeneration, animationSpeed, incrementSteps) {\n  // Add vertical wall with passage\n  const newWallCells = [];\n  for (let row = startRow; row < startRow + height; row++) {\n    if (row !== passageRow) {\n      const cellKey = `${row}-${wallCol}`;\n      walls.add(cellKey);\n      mazeGenerationCells.add(cellKey);\n      newWallCells.push(cellKey);\n    }\n  }\n\n  // Animate the wall creation\n  incrementSteps();\n  updateWalls(new Set(walls));\n  updateMazeGeneration(new Set(mazeGenerationCells));\n  await sleep(animationSpeed);\n\n  // Remove the wall cells from generation display after a short delay\n  setTimeout(() => {\n    newWallCells.forEach(cell => mazeGenerationCells.delete(cell));\n    updateMazeGeneration(new Set(mazeGenerationCells));\n  }, animationSpeed * 2);\n}\n\n/**\n * Create a horizontal wall with a passage\n */\nasync function createHorizontalWall(startCol, wallRow, width, passageCol, walls, mazeGenerationCells, updateWalls, updateMazeGeneration, animationSpeed, incrementSteps) {\n  // Add horizontal wall with passage\n  const newWallCells = [];\n  for (let col = startCol; col < startCol + width; col++) {\n    if (col !== passageCol) {\n      const cellKey = `${wallRow}-${col}`;\n      walls.add(cellKey);\n      mazeGenerationCells.add(cellKey);\n      newWallCells.push(cellKey);\n    }\n  }\n\n  // Animate the wall creation\n  incrementSteps();\n  updateWalls(new Set(walls));\n  updateMazeGeneration(new Set(mazeGenerationCells));\n  await sleep(animationSpeed);\n\n  // Remove the wall cells from generation display after a short delay\n  setTimeout(() => {\n    newWallCells.forEach(cell => mazeGenerationCells.delete(cell));\n    updateMazeGeneration(new Set(mazeGenerationCells));\n  }, animationSpeed * 2);\n}\n\n/**\n * Sleep function for animation delays\n */\nfunction sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n/**\n * Generate maze steps for step-by-step visualization (simplified version)\n */\nexport const getRecursiveDivisionSteps = gridSize => {\n  const steps = [];\n  const walls = new Set();\n\n  // Initialize with border walls\n  for (let row = 0; row < gridSize; row++) {\n    for (let col = 0; col < gridSize; col++) {\n      if (row === 0 || row === gridSize - 1 || col === 0 || col === gridSize - 1) {\n        walls.add(`${row}-${col}`);\n      }\n    }\n  }\n  steps.push({\n    walls: new Set(walls),\n    action: 'start',\n    description: 'Starting with border walls only'\n  });\n\n  // This would contain the recursive division steps\n  // For now, return the initial step\n  return steps;\n};\nexport default generateMazeWithRecursiveDivision;","map":{"version":3,"names":["generateMazeWithRecursiveDivision","gridSize","updateWalls","updateMazeGeneration","animationSpeed","startPos","row","col","targetPos","walls","Set","mazeGenerationCells","generationSteps","add","sleep","recursiveDivide","setTimeout","visitedCells","size","x","y","width","height","horizontal","incrementSteps","wallY","Math","floor","random","passageX","createHorizontalWall","wallX","passageY","createVerticalWall","wallCol","startRow","passageRow","newWallCells","cellKey","push","forEach","cell","delete","startCol","wallRow","passageCol","ms","Promise","resolve","getRecursiveDivisionSteps","steps","action","description"],"sources":["E:/maze_analyser/src/algorithms/recursiveDivision.js"],"sourcesContent":["/**\n * Recursive Division Algorithm for Maze Generation\n * \n * This algorithm generates a maze by starting with an empty space and \n * recursively dividing it with walls, leaving passages through each wall.\n * \n * Data Structures Used:\n * - Set: For tracking walls and division cells\n * - Array: For managing division operations and animation steps\n * - Recursive function calls: For the division process\n */\n\n/**\n * Generates a maze using Recursive Division algorithm with systematic grid-like animation\n * @param {number} gridSize - The size of the grid (gridSize x gridSize)\n * @param {Function} updateWalls - Callback to update UI with current walls\n * @param {Function} updateMazeGeneration - Callback to update UI with maze generation cells\n * @param {number} animationSpeed - Speed of animation in milliseconds\n * @param {Object} startPos - Starting position {row, col}\n * @param {Object} targetPos - Target position {row, col}\n * @returns {Object} - Results including final walls set and generation stats\n */\nexport const generateMazeWithRecursiveDivision = async (\n  gridSize,\n  updateWalls,\n  updateMazeGeneration,\n  animationSpeed = 120,\n  startPos = { row: 1, col: 1 },\n  targetPos = { row: gridSize - 2, col: gridSize - 2 }\n) => {\n  const walls = new Set();\n  const mazeGenerationCells = new Set();\n  let generationSteps = 0;\n  \n  // Initialize: Start with border walls only\n  for (let row = 0; row < gridSize; row++) {\n    for (let col = 0; col < gridSize; col++) {\n      // Only create border walls initially\n      if (row === 0 || row === gridSize - 1 || col === 0 || col === gridSize - 1) {\n        walls.add(`${row}-${col}`);\n      }\n    }\n  }\n  \n  // Update initial state (empty interior with border walls)\n  updateWalls(new Set(walls));\n  updateMazeGeneration(new Set());\n  await sleep(animationSpeed);\n  \n  // Start classic recursive division on the entire interior space\n  await recursiveDivide(\n    1, 1, // top-left of interior\n    gridSize - 2, gridSize - 2, // width and height of interior\n    true, // start with horizontal division\n    walls,\n    mazeGenerationCells,\n    updateWalls,\n    updateMazeGeneration,\n    animationSpeed,\n    () => { generationSteps++; },\n    startPos,\n    targetPos\n  );\n  \n  // Clear maze generation cells after completion\n  setTimeout(() => {\n    updateMazeGeneration(new Set());\n  }, 1500);\n  \n  return {\n    walls: new Set(walls),\n    generationSteps,\n    visitedCells: gridSize * gridSize - walls.size\n  };\n};\n\n/**\n * Classic Recursive Division Algorithm\n * Recursively divides areas with alternating horizontal and vertical walls\n * @param {number} x - Left boundary of the area\n * @param {number} y - Top boundary of the area\n * @param {number} width - Width of the area\n * @param {number} height - Height of the area\n * @param {boolean} horizontal - Whether to divide horizontally (true) or vertically (false)\n * @param {Set} walls - Current walls set\n * @param {Set} mazeGenerationCells - Cells being processed\n * @param {Function} updateWalls - Callback to update walls\n * @param {Function} updateMazeGeneration - Callback to update generation cells\n * @param {number} animationSpeed - Animation delay\n * @param {Function} incrementSteps - Callback to increment step counter\n * @param {Object} startPos - Starting position {row, col}\n * @param {Object} targetPos - Target position {row, col}\n */\nasync function recursiveDivide(\n  x, y, width, height, horizontal,\n  walls, mazeGenerationCells,\n  updateWalls, updateMazeGeneration,\n  animationSpeed, incrementSteps,\n  startPos, targetPos\n) {\n  // Base case: area too small to divide\n  if (width < 2 || height < 2) {\n    return;\n  }\n  \n  if (horizontal) {\n    // Divide horizontally\n    if (height < 3) return; // Need at least 3 cells to divide horizontally\n    \n    // Choose a random row to place the wall (avoid edges)\n    const wallY = y + 1 + Math.floor(Math.random() * (height - 2));\n    \n    // Choose a random position for the passage\n    const passageX = x + Math.floor(Math.random() * width);\n    \n    // Create horizontal wall with passage\n    await createHorizontalWall(\n      x, wallY, width, passageX,\n      walls, mazeGenerationCells,\n      updateWalls, updateMazeGeneration,\n      animationSpeed, incrementSteps\n    );\n    \n    // Recursively divide the two new areas (switch to vertical)\n    await recursiveDivide(\n      x, y, width, wallY - y, false, // top area, switch to vertical\n      walls, mazeGenerationCells,\n      updateWalls, updateMazeGeneration,\n      animationSpeed, incrementSteps,\n      startPos, targetPos\n    );\n    \n    await recursiveDivide(\n      x, wallY + 1, width, height - (wallY - y + 1), false, // bottom area, switch to vertical\n      walls, mazeGenerationCells,\n      updateWalls, updateMazeGeneration,\n      animationSpeed, incrementSteps,\n      startPos, targetPos\n    );\n    \n  } else {\n    // Divide vertically\n    if (width < 3) return; // Need at least 3 cells to divide vertically\n    \n    // Choose a random column to place the wall (avoid edges)\n    const wallX = x + 1 + Math.floor(Math.random() * (width - 2));\n    \n    // Choose a random position for the passage\n    const passageY = y + Math.floor(Math.random() * height);\n    \n    // Create vertical wall with passage\n    await createVerticalWall(\n      wallX, y, height, passageY,\n      walls, mazeGenerationCells,\n      updateWalls, updateMazeGeneration,\n      animationSpeed, incrementSteps\n    );\n    \n    // Recursively divide the two new areas (switch to horizontal)\n    await recursiveDivide(\n      x, y, wallX - x, height, true, // left area, switch to horizontal\n      walls, mazeGenerationCells,\n      updateWalls, updateMazeGeneration,\n      animationSpeed, incrementSteps,\n      startPos, targetPos\n    );\n    \n    await recursiveDivide(\n      wallX + 1, y, width - (wallX - x + 1), height, true, // right area, switch to horizontal\n      walls, mazeGenerationCells,\n      updateWalls, updateMazeGeneration,\n      animationSpeed, incrementSteps,\n      startPos, targetPos\n    );\n  }\n}\n\n/**\n * Create a vertical wall with a passage\n */\nasync function createVerticalWall(\n  wallCol, startRow, height, passageRow,\n  walls, mazeGenerationCells,\n  updateWalls, updateMazeGeneration,\n  animationSpeed, incrementSteps\n) {\n  // Add vertical wall with passage\n  const newWallCells = [];\n  for (let row = startRow; row < startRow + height; row++) {\n    if (row !== passageRow) {\n      const cellKey = `${row}-${wallCol}`;\n      walls.add(cellKey);\n      mazeGenerationCells.add(cellKey);\n      newWallCells.push(cellKey);\n    }\n  }\n  \n  // Animate the wall creation\n  incrementSteps();\n  updateWalls(new Set(walls));\n  updateMazeGeneration(new Set(mazeGenerationCells));\n  await sleep(animationSpeed);\n  \n  // Remove the wall cells from generation display after a short delay\n  setTimeout(() => {\n    newWallCells.forEach(cell => mazeGenerationCells.delete(cell));\n    updateMazeGeneration(new Set(mazeGenerationCells));\n  }, animationSpeed * 2);\n}\n\n/**\n * Create a horizontal wall with a passage\n */\nasync function createHorizontalWall(\n  startCol, wallRow, width, passageCol,\n  walls, mazeGenerationCells,\n  updateWalls, updateMazeGeneration,\n  animationSpeed, incrementSteps\n) {\n  // Add horizontal wall with passage\n  const newWallCells = [];\n  for (let col = startCol; col < startCol + width; col++) {\n    if (col !== passageCol) {\n      const cellKey = `${wallRow}-${col}`;\n      walls.add(cellKey);\n      mazeGenerationCells.add(cellKey);\n      newWallCells.push(cellKey);\n    }\n  }\n  \n  // Animate the wall creation\n  incrementSteps();\n  updateWalls(new Set(walls));\n  updateMazeGeneration(new Set(mazeGenerationCells));\n  await sleep(animationSpeed);\n  \n  // Remove the wall cells from generation display after a short delay\n  setTimeout(() => {\n    newWallCells.forEach(cell => mazeGenerationCells.delete(cell));\n    updateMazeGeneration(new Set(mazeGenerationCells));\n  }, animationSpeed * 2);\n}\n\n\n\n/**\n * Sleep function for animation delays\n */\nfunction sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n/**\n * Generate maze steps for step-by-step visualization (simplified version)\n */\nexport const getRecursiveDivisionSteps = (gridSize) => {\n  const steps = [];\n  const walls = new Set();\n  \n  // Initialize with border walls\n  for (let row = 0; row < gridSize; row++) {\n    for (let col = 0; col < gridSize; col++) {\n      if (row === 0 || row === gridSize - 1 || col === 0 || col === gridSize - 1) {\n        walls.add(`${row}-${col}`);\n      }\n    }\n  }\n  \n  steps.push({\n    walls: new Set(walls),\n    action: 'start',\n    description: 'Starting with border walls only'\n  });\n  \n  // This would contain the recursive division steps\n  // For now, return the initial step\n  return steps;\n};\n\nexport default generateMazeWithRecursiveDivision;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}